
Wireshark User’s Guide

Version 4.1.0

Richard Sharpe, Ed Warnicke, Ulf Lamping

Preface
Foreword
Wireshark is the world’s foremost network protocol analyzer, but the rich feature set can be
daunting for the unfamiliar. This document is part of an effort by the Wireshark team to improve
Wireshark’s usability. We hope that you find it useful and look forward to your comments.

Who should read this document?
The intended audience of this book is anyone using Wireshark.
This book explains all of the basic and some advanced features of Wireshark. As Wireshark has
become a very complex program, not every feature may be explained in this book.
This book is not intended to explain network sniffing in general and it will not provide details
about specific network protocols. A lot of useful information regarding these topics can be found at
the Wireshark Wiki at https://gitlab.com/wireshark/wireshark/-/wikis/.
By reading this book, you will learn how to install Wireshark, how to use the basic elements of the
graphical user interface (such as the menu) and what’s behind some of the advanced features that
are not always obvious at first sight. It will hopefully guide you around some common problems
that frequently appear for new (and sometimes even advanced) Wireshark users.

Acknowledgements
The authors would like to thank the whole Wireshark team for their assistance. In particular, the
authors would like to thank:
• Gerald Combs, for initiating the Wireshark project and funding to do this documentation.
• Guy Harris, for many helpful hints and a great deal of patience in reviewing this document.
• Gilbert Ramirez, for general encouragement and helpful hints along the way.
The authors would also like to thank the following people for their helpful feedback on this
document:
• Pat Eyler, for his suggestions on improving the example on generating a backtrace.
• Martin Regner, for his various suggestions and corrections.
• Graeme Hewson, for many grammatical corrections.
The authors would like to acknowledge those man page and README authors for the Wireshark
project from who sections of this document borrow heavily:

1

• Scott Renfro from whose mergecap man page mergecap: Merging multiple capture files into one
is derived.
• Ashok Narayanan from whose text2pcap man page text2pcap: Converting ASCII hexdumps to
network captures is derived.

About this document
This book was originally developed by Richard Sharpe with funds provided from the Wireshark
Fund. It was updated by Ed Warnicke and more recently redesigned and updated by Ulf Lamping.
It was originally written in DocBook/XML and converted to AsciiDoc by Gerald Combs.

Where to get the latest copy of this document?
The latest copy of this documentation can always be found at https://www.wireshark.org/docs/
wsug_html_chunked/.

Providing feedback about this document
Should you have any feedback about this document, please send it to the authors through
wireshark-dev[AT]wireshark.org.

Typographic Conventions
The following table shows the typographic conventions that are used in this guide.
Table 1. Typographic Conventions

Style

Description

Example

Italic

File names, folder names, and extensions C:\Development\wireshark.

Monospace

Commands, flags, and environment

CMake’s -G option.

variables
Bold
Monospace

Commands that should be run by the

Run cmake -G Ninja ...

[ Button ]

Dialog and window buttons

Press [ Launch ] to go to the Moon.

Key

Keyboard shortcut

Press Ctrl + Down to move to the next

user

packet.
Menu

Menu item

Select Go › Next Packet to move to the
next packet.

2

Admonitions
Important and notable items are marked as follows:

WARNING

Act carefully (i.e., exercise care).

IMPORTANT

NOTE

You should pay attention to a warning, otherwise data loss might occur.
This is a caution

CAUTION

TIP

This is a warning

This is important information

RTFM - Read The Fine Manual

This is a tip

Tips are helpful for your everyday work using Wireshark.
This is a note

A note will point you to common mistakes and things that might not be obvious.

Shell Prompt and Source Code Examples
Bourne shell, normal user

$ # This is a comment
$ git config --global log.abbrevcommit true
Bourne shell, root user

# # This is a comment
# ninja install
Command Prompt (cmd.exe)

>rem This is a comment
>cd C:\Development
PowerShell

PS$># This is a comment
PS$> choco list -l

3

C Source Code

#include "config.h"
/* This method dissects foos */
static int
dissect_foo_message(tvbuff_t *tvb, packet_info *pinfo _U_, proto_tree *tree _U_, void
*data _U_)
{
/* TODO: implement your dissecting code */
return tvb_captured_length(tvb);
}

4

Introduction
What is Wireshark?
Wireshark is a network packet analyzer. A network packet analyzer presents captured packet data
in as much detail as possible.
You could think of a network packet analyzer as a measuring device for examining what’s
happening inside a network cable, just like an electrician uses a voltmeter for examining what’s
happening inside an electric cable (but at a higher level, of course).
In the past, such tools were either very expensive, proprietary, or both. However, with the advent
of Wireshark, that has changed. Wireshark is available for free, is open source, and is one of the
best packet analyzers available today.

Some intended purposes
Here are some reasons people use Wireshark:
• Network administrators use it to troubleshoot network problems
• Network security engineers use it to examine security problems
• QA engineers use it to verify network applications
• Developers use it to debug protocol implementations
• People use it to learn network protocol internals
Wireshark can also be helpful in many other situations.

Features
The following are some of the many features Wireshark provides:
• Available for UNIX and Windows.
• Capture live packet data from a network interface.
• Open files containing packet data captured with tcpdump/WinDump, Wireshark, and many
other packet capture programs.
• Import packets from text files containing hex dumps of packet data.
• Display packets with very detailed protocol information.
• Save packet data captured.
• Export some or all packets in a number of capture file formats.
• Filter packets on many criteria.

5

• Search for packets on many criteria.
• Colorize packet display based on filters.
• Create various statistics.
• …and a lot more!
However, to really appreciate its power you have to start using it.
Wireshark captures packets and lets you examine their contents. shows Wireshark having captured
some packets and waiting for you to examine them.

check the screen below

Figure 1. Wireshark captures packets and lets you examine their contents.

Live capture from many different network media
Wireshark can capture traffic from many different network media types, including Ethernet,
Wireless LAN, Bluetooth, USB, and more. The specific media types supported may be limited by
several factors, including your hardware and operating system. An overview of the supported
media

types

can

be

found

at

https://gitlab.com/wireshark/wireshark/-/wikis/CaptureSetup/

NetworkMedia.

Import files from many other capture programs
Wireshark can open packet captures from a large number of capture programs. For a list of input
formats see Input File Formats.

6

Export files for many other capture programs
Wireshark can save captured packets in many formats, including those used by other capture
programs. For a list of output formats see Output File Formats.

Many protocol dissectors
There are protocol dissectors (or decoders, as they are known in other products) for a great many
protocols: see Protocols and Protocol Fields.

Open Source Software
Wireshark is an open source software project, and is released under the GNU General Public
License (GPL). You can freely use Wireshark on any number of computers you like, without
worrying about license keys or fees or such. In addition, all source code is freely available under
the GPL. Because of that, it is very easy for people to add new protocols to Wireshark, either as
plugins, or built into the source, and they often do!

What Wireshark is not
Here are some things Wireshark does not provide:
• Wireshark isn’t an intrusion detection system. It will not warn you when someone does strange
things on your network that he/she isn’t allowed to do. However, if strange things happen,
Wireshark might help you figure out what is really going on.
• Wireshark will not manipulate things on the network, it will only “measure” things from it.
Wireshark doesn’t send packets on the network or do other active things (except domain name
resolution, but that can be disabled).

System Requirements
The amount of resources Wireshark needs depends on your environment and on the size of the
capture file you are analyzing. The values below should be fine for small to medium-sized capture
files no more than a few hundred MB. Larger capture files will require more memory and disk
space.
Busy networks mean large captures

NOTE

A busy network can produce huge capture files. Capturing on even a 100 megabit
network can produce hundreds of megabytes of capture data in a short time. A
computer with a fast processor, and lots of memory and disk space is always a good
idea.

If Wireshark runs out of memory it will crash. See https://gitlab.com/wireshark/wireshark/-/wikis/
KnownBugs/OutOfMemory for details and workarounds.

7

Although Wireshark uses a separate process to capture packets, the packet analysis is singlethreaded and won’t benefit much from multi-core systems.

Microsoft Windows
Wireshark should support any version of Windows that is still within its extended support lifetime.
At the time of writing this includes Windows 10, 8.1, Server 2019, Server 2016, Server 2012 R2, and
Server 2012. It also requires the following:
• The Universal C Runtime. This is included with Windows 10 and Windows Server 2019 and is
installed automatically on earlier versions if Microsoft Windows Update is enabled. Otherwise
you must install KB2999226 or KB3118401.
• Any modern 64-bit Intel or Arm processor.
• 500 MB available RAM. Larger capture files require more RAM.
• 500 MB available disk space. Capture files require additional disk space.
• Any modern display. 1280 × 1024 or higher resolution is recommended. Wireshark will make
use of HiDPI or Retina resolutions if available. Power users will find multiple monitors useful.
• A supported network card for capturing
◦ Ethernet. Any card supported by Windows should work. See the wiki pages on Ethernet
capture and offloading for issues that may affect your environment.
◦ 802.11. See the Wireshark wiki page. Capturing raw 802.11 information may be difficult
without special equipment.
◦ Other

media.

See

https://gitlab.com/wireshark/wireshark/-/wikis/CaptureSetup/

NetworkMedia.
Older versions of Windows which are outside Microsoft’s extended lifecycle support window are no
longer supported. It is often difficult or impossible to support these systems due to circumstances
beyond our control, such as third party libraries on which we depend or due to necessary features
that are only present in newer versions of Windows such as hardened security or memory
management.
• Wireshark 3.6 was the last release branch to officially support 32-bit Windows.
• Wireshark 3.2 was the last release branch to officially support Windows 7 and Windows Server
2008 R2.
• Wireshark 2.2 was the last release branch to support Windows Vista and Windows Server 2008
sans R2
• Wireshark 1.12 was the last release branch to support Windows Server 2003.
• Wireshark 1.10 was the last release branch to officially support Windows XP.
See the Wireshark release lifecycle page for more details.

8

macOS
Wireshark supports macOS 10.14 and later. Similar to Windows, supported macOS versions depend
on third party libraries and on Apple’s requirements. Apple Silicon hardware is supported natively
starting with version 4.0
• Wireshark 3.6 was the last release branch to support macOS 10.13.
• Wireshark 3.4 was the last release branch to support macOS 10.12.
• Wireshark 2.6 was the last release branch to support Mac OS X 10.6 and 10.7 and OS X 10.8 to
10.11.
• Wireshark 2.0 was the last release branch to support OS X on 32-bit Intel.
• Wireshark 1.8 was the last release branch to support Mac OS X on PowerPC.
The system requirements should be comparable to the specifications listed above for Windows.

UNIX, Linux, and BSD
Wireshark runs on most UNIX and UNIX-like platforms including Linux and most BSD variants. The
system requirements should be comparable to the specifications listed above for Windows.
Binary packages are available for most Unices and Linux distributions including the following
platforms:
• Alpine Linux
• Arch Linux
• Canonical Ubuntu
• Debian GNU/Linux
• FreeBSD
• Gentoo Linux
• HP-UX
• NetBSD
• OpenPKG
• Oracle Solaris
• Red Hat Enterprise Linux / CentOS / Fedora
If a binary package is not available for your platform you can download the source and try to build
it. Please report your experiences to wireshark-dev[AT]wireshark.org.

9

Where To Get Wireshark
You

can

get

the

latest

copy

of

the

program

from

the

Wireshark

website

at

https://www.wireshark.org/download.html. The download page should automatically highlight the
appropriate download for your platform and direct you to the nearest mirror. Official Windows
and macOS installers are signed using trusted certificates on those platforms. macOS installers are
additionally notarized.
A new Wireshark version typically becomes available every six weeks.
If you want to be notified about new Wireshark releases you should subscribe to the wiresharkannounce mailing list. You will find more details in Mailing Lists.
Each release includes a list of file hashes which are sent to the wireshark-announce mailing list and
placed in a file named SIGNATURES-x.y.z.txt. Announcement messages are archived at
https://www.wireshark.org/lists/wireshark-announce/ and SIGNATURES files can be found at
https://www.wireshark.org/download/src/all-versions/.

Both

are

GPG-signed

and

include

verification instructions for Windows, Linux, and macOS. As noted above, you can also verify
downloads on Windows and macOS using the code signature validation features on those systems.

A Brief History Of Wireshark
In late 1997 Gerald Combs needed a tool for tracking down network problems and wanted to learn
more about networking so he started writing Ethereal (the original name of the Wireshark project)
as a way to solve both problems.
Ethereal was initially released after several pauses in development in July 1998 as version 0.2.0.
Within days patches, bug reports, and words of encouragement started arriving and Ethereal was
on its way to success.
Not long after that Gilbert Ramirez saw its potential and contributed a low-level dissector to it.
In October, 1998 Guy Harris was looking for something better than tcpview so he started applying
patches and contributing dissectors to Ethereal.
In late 1998 Richard Sharpe, who was giving TCP/IP courses, saw its potential on such courses and
started looking at it to see if it supported the protocols he needed. While it didn’t at that point new
protocols could be easily added. So he started contributing dissectors and contributing patches.
The list of people who have contributed to the project has become very long since then, and almost
all of them started with a protocol that they needed that Wireshark did not already handle. So they
copied an existing dissector and contributed the code back to the team.
In 2006 the project moved house and re-emerged under a new name: Wireshark.
In 2008, after ten years of development, Wireshark finally arrived at version 1.0. This release was

10

the first deemed complete, with the minimum features implemented. Its release coincided with the
first Wireshark Developer and User Conference, called Sharkfest.
In 2015 Wireshark 2.0 was released, which featured a new user interface.

Development And Maintenance Of Wireshark
Wireshark was initially developed by Gerald Combs. Ongoing development and maintenance of
Wireshark is handled by the Wireshark team, a loose group of individuals who fix bugs and
provide new functionality.
There have also been a large number of people who have contributed protocol dissectors to
Wireshark, and it is expected that this will continue. You can find a list of the people who have
contributed code to Wireshark by checking the about dialog box of Wireshark, or at the authors
page on the Wireshark web site.
Wireshark is an open source software project, and is released under the GNU General Public
License (GPL) version 2. All source code is freely available under the GPL. You are welcome to
modify Wireshark to suit your own needs, and it would be appreciated if you contribute your
improvements back to the Wireshark team.
You gain three benefits by contributing your improvements back to the community:
1. Other people who find your contributions useful will appreciate them, and you will know that
you have helped people in the same way that the developers of Wireshark have helped you.
2. The developers of Wireshark can further improve your changes or implement additional
features on top of your code, which may also benefit you.
3. The maintainers and developers of Wireshark will maintain your code, fixing it when API
changes or other changes are made, and generally keeping it in tune with what is happening
with Wireshark. So when Wireshark is updated (which is often), you can get a new Wireshark
version from the website and your changes will already be included without any additional
effort from you.
The Wireshark source code and binary kits for some platforms are all available on the download
page of the Wireshark website: https://www.wireshark.org/download.html.

Reporting Problems And Getting Help
If you have problems or need help with Wireshark there are several places that may be of interest
(besides this guide, of course).

Website
You will find lots of useful information on the Wireshark homepage at https://www.wireshark.org/.

11

Wiki
The Wireshark Wiki at https://gitlab.com/wireshark/wireshark/-/wikis/ provides a wide range of
information related to Wireshark and packet capture in general. You will find a lot of information
not part of this user’s guide. For example, it contains an explanation how to capture on a switched
network, an ongoing effort to build a protocol reference, protocol-specific information, and much
more.
And best of all, if you would like to contribute your knowledge on a specific topic (maybe a network
protocol you know well), you can edit the wiki pages with your web browser.

Q&A Site
The Wireshark Q&A site at https://ask.wireshark.org/ offers a resource where questions and
answers come together. You can search for questions asked before and see what answers were
given by people who knew about the issue. Answers are ranked, so you can easily pick out the best
ones. If your question hasn’t been discussed before you can post one yourself.

FAQ
The Frequently Asked Questions lists often asked questions and their corresponding answers.
Read the FAQ

NOTE

Before sending any mail to the mailing lists below, be sure to read the FAQ. It will
often answer any questions you might have. This will save yourself and others a lot
of time. Keep in mind that a lot of people are subscribed to the mailing lists.

You will find the FAQ inside Wireshark by clicking the menu item Help/Contents and selecting the
FAQ page in the dialog shown.
An online version is available at the Wireshark website at https://www.wireshark.org/faq.html. You
might prefer this online version, as it’s typically more up to date and the HTML format is easier to
use.

Mailing Lists
There are several mailing lists of specific Wireshark topics available:
wireshark-announce
Information about new program releases, which usually appear about every six weeks.
wireshark-users
Topics of interest to users of Wireshark. People typically post questions about using Wireshark
and others (hopefully) provide answers.

12

wireshark-dev
Topics of interest to developers of Wireshark. If you want to develop a protocol dissector or
update the user interface, join this list.
You can subscribe to each of these lists from the Wireshark web site: https://www.wireshark.org/
lists/. From there, you can choose which mailing list you want to subscribe to by clicking on the
Subscribe/Unsubscribe/Options button under the title of the relevant list. The links to the archives
are included on that page as well.
The lists are archived

TIP

You can search in the list archives to see if someone asked the same question some
time before and maybe already got an answer. That way you don’t have to wait until
someone answers your question.

Reporting Problems
NOTE

Before reporting any problems, please make sure you have installed the latest
version of Wireshark.

When reporting problems with Wireshark please supply the following information:
1. The version number of Wireshark and the dependent libraries linked with it, such as Qt or GLib.
You can obtain this from Wireshark’s about box or the command wireshark -v.
2. Information about the platform you run Wireshark on (Windows, Linux, etc. and 32-bit, 64-bit,
etc.).
3. A detailed description of your problem.
4. If you get an error/warning message, copy the text of that message (and also a few lines before
and after it, if there are some) so others may find the place where things go wrong. Please don’t
give something like: “I get a warning while doing x” as this won’t give a good idea where to look.
Don’t send confidential information!

If you send capture files to the mailing lists be sure they don’t contain any
WARNING

sensitive or confidential information like passwords or personally identifiable
information (PII).
In many cases you can use a tool like TraceWrangler to sanitize a capture file
before sharing it.

Don’t send large files

NOTE

Do not send large files (> 1 MB) to the mailing lists. Instead, provide a download
link. For bugs and feature requests, you can create an issue on GitLab Issues and
upload the file there.

13

Reporting Crashes on UNIX/Linux platforms
When reporting crashes with Wireshark it is helpful if you supply the traceback information along
with the information mentioned in “Reporting Problems”.
You can obtain this traceback information with the following commands on UNIX or Linux (note
the backticks):

$ gdb `whereis wireshark | cut -f2 -d: | cut -d' ' -f2` core >& backtrace.txt
backtrace
^D
If you do not have gdb available, you will have to check out your operating system’s debugger.
Email backtrace.txt to wireshark-dev[AT]wireshark.org.

Reporting Crashes on Windows platforms
The Windows distributions don’t contain the symbol files (.pdb) because they are very large. You
can download them separately at https://www.wireshark.org/download/win32/all-versions/ and
https://www.wireshark.org/download/win64/all-versions/ .

14

Building and Installing Wireshark
Introduction
As with all things there must be a beginning and so it is with Wireshark. To use Wireshark you
must first install it. If you are running Windows or macOS you can download an official release at
https://www.wireshark.org/download.html, install it, and skip the rest of this chapter.
If you are running another operating system such as Linux or FreeBSD you might want to install
from source. Several Linux distributions offer Wireshark packages but they commonly provide outof-date versions. No other versions of UNIX ship Wireshark so far. For that reason, you will need to
know where to get the latest version of Wireshark and how to install it.
This chapter shows you how to obtain source and binary packages and how to build Wireshark
from source should you choose to do so.
The general steps are the following:
1. Download the relevant package for your needs, e.g., source or binary distribution.
2. For source distributions, compile the source into a binary. This may involve building and/or
installing other necessary packages.
3. Install the binaries into their final destinations.

Obtaining the source and binary distributions
You can obtain both source and binary distributions from the Wireshark main page or the
download page at https://www.wireshark.org/download.html. Select the package most appropriate
for your system.

Installing Wireshark under Windows
The official Windows packages can be downloaded from the Wireshark main page or the download
page. Installer names contain the version and platform. For example, Wireshark-4.1.0-x64.exe
installs Wireshark 4.1.0 for Windows on 64-bit Intel processors. The Wireshark installer includes
Npcap which is required for packet capture. Windows packages automatically update. See Updating
Wireshark for details.
Simply download the Wireshark installer from https://www.wireshark.org/download.html and
execute it. Official packages are signed by Wireshark Foundation. You can choose to install several
optional components and select the location of the installed package. The default settings are
recommended for most users.

15

Installation Components
On the Choose Components page of the installer you can select from the following:
• Wireshark - The network protocol analyzer that we all know and mostly love.
• TShark - A command-line network protocol analyzer. If you haven’t tried it you should.
• Plugins & Extensions - Extras for the Wireshark and TShark dissection engines
◦ Codec Plugins - Additional codec support.
◦ Configuration Profiles - Additional configuration profiles.
◦ Dissector Plugins - Additional protocol dissectors.
◦ File Type Plugins - capture file support - Extend wiretap support for capture file types.
(e.g. usbdump)
◦ Mate - Meta Analysis and Tracing Engine - User configurable extension(s) of the display
filter engine, see MATE for details.
◦ SNMP MIBs - SNMP MIBs for a more detailed SNMP dissection.
◦ TRANSUM - performance analysis - Plugin to calculate Response Time Element (RTE)
statistics.
◦ Tree Statistics Plugin - Extended statistics. (see stats_tree in WSDG; Packet Lengths in
WSUG)
• Tools - Additional command line tools to work with capture files and troubleshoot
◦ Capinfos - Print information about capture files.
◦ Captype - Print the type(format) of capture files.
◦ DFTest - Show display filter byte-code, for debugging dfilter routines.
◦ Editcap - Copy packets to a new file, optionally trimming packets, omitting them, or saving
to a different format.
◦ Mergecap - Combine multiple saved capture files into a single output file.
◦ MMDBResolve - MaxMind Database resolution tool - read IPv4 and IPv6 addresses and print
their IP geolocation information.
◦ Randpkt - Create a pcap trace file full of random packets. (randpkt produces very bad
packets)
◦ Rawshark - Dump and analyze raw pcap data.
◦ Reordercap - Copy packets to a new file, sorted by time.
◦ Text2Pcap - Generate a capture file from an ASCII hexdump of packets.
• External Capture (extcap) - External Capture Interfaces
◦ Androiddump - Provide capture interfaces from Android devices.
◦ Etwdump - Provide an interface to read Event Tracing for Windows (ETW) event trace

16

(ETL).
◦ Randpktdump - Provide an interface to the random packet generator. (see also randpkt)
◦ Sshdump, Ciscodump, and Wifidump - Provide remote capture through SSH. (tcpdump,
Cisco EPC, wifi)
◦ UDPdump - Provide capture interface to receive UDP packets streamed from network
devices.
• Documentation - Local installation of the User’s Guide and FAQ. The Help buttons on most
dialogs will require an internet connection to show help pages if the User’s Guide is not
installed locally.

Additional Tasks
• Wireshark Start Menu Item - Add a shortcut to the start menu.
• Wireshark Desktop Icon - Add a Wireshark icon to the desktop.
• Associate trace file extensions with Wireshark - Associate standard network trace files to
Wireshark.

Install Location
By

default

Wireshark

installs

into

%ProgramFiles%\Wireshark

on

32-bit

Windows

and

%ProgramFiles64%\Wireshark on 64-bit Windows. This expands to C:\Program Files\Wireshark on
most systems.

Installing Npcap
The Wireshark installer contains the latest Npcap installer.
If you don’t have Npcap installed you won’t be able to capture live network traffic but you will still
be able to open saved capture files. By default the latest version of Npcap will be installed. If you
don’t wish to do this or if you wish to reinstall Npcap you can check the Install Npcap box as
needed.
For more information about Npcap see https://npcap.com/ and https://gitlab.com/wireshark/
wireshark/-/wikis/Npcap.

Windows installer command line options
For special cases, there are some command line parameters available:
• /S runs the installer or uninstaller silently with default values. The silent installer will not
install Npcap.
• /desktopicon installation of the desktop icon, =yes - force installation, =no - don’t install,
otherwise use default settings. This option can be useful for a silent installer.

17

• /quicklaunchicon installation of the quick launch icon, =yes - force installation, =no - don’t install,
otherwise use default settings.
• /D sets the default installation directory ($INSTDIR), overriding InstallDir and InstallDirRegKey.
It must be the last parameter used in the command line and must not contain any quotes even if
the path contains spaces.
• /NCRC disables the CRC check. We recommend against using this flag.
• /EXTRACOMPONENTS comma separated list of optional components to install. The following extcap
binaries are supported.
◦ androiddump - Provide interfaces to capture from Android devices
◦ ciscodump - Provide interfaces to capture from a remote Cisco router through SSH
◦ randpktdump - Provide an interface to generate random captures using randpkt
◦ sshdump - Provide interfaces to capture from a remote host through SSH using a remote
capture binary
◦ udpdump - Provide a UDP receiver that gets packets from network devices
Example:

> Wireshark-4.2.5-x64.exe /NCRC /S /desktopicon=yes /quicklaunchicon=no /D=C:\Program
Files\Foo
> Wireshark-4.2.5-x64.exe /S /EXTRACOMPONENTS=sshdump,udpdump
Running the installer without any parameters shows the normal interactive installer.

Manual Npcap Installation
As mentioned above, the Wireshark installer also installs Npcap. If you prefer to install Npcap
manually or want to use a different version than the one included in the Wireshark installer, you
can download Npcap from the main Npcap site at https://npcap.com/.

Update Npcap
Wireshark updates may also include a new version of Npcap. Manual Npcap updates instructions
can be found on the Npcap web site at https://npcap.com/. You may have to reboot your machine
after installing a new Npcap version.

Uninstall Wireshark
You can uninstall Wireshark using the Programs and Features control panel. Select the “Wireshark”
entry to start the uninstallation procedure.
The Wireshark uninstaller provides several options for removal. The default is to remove the core

18

components but keep your personal settings and Npcap. Npcap is kept in case other programs need
it.

Uninstall Npcap
You can uninstall Npcap independently of Wireshark using the Npcap entry in the Programs and
Features control panel. Remember that if you uninstall Npcap you won’t be able to capture
anything with Wireshark.

Building from source under Windows
We strongly recommended using the binary installer for Windows unless you want to start
developing Wireshark on the Windows platform.
For further information how to obtain sources and build Wireshark for Windows from the sources
see the Developer’s Guide at:
• https://www.wireshark.org/docs/wsdg_html_chunked/ChSrcObtain
• https://www.wireshark.org/docs/wsdg_html_chunked/ChSetupWindows
You may also want to have a look at the Development Wiki (https://gitlab.com/wireshark/wireshark/
-/wikis/Development) for the latest available development documentation.

Installing Wireshark under macOS
The official macOS packages can be downloaded from the Wireshark main page or the download
page. Packages are distributed as disk images (.dmg) containing the application bundle. Package
names contain the platform and version. To install Wireshark simply open the disk image and drag
Wireshark to your /Applications folder. macOS packages automatically update. See Updating
Wireshark for details.
In order to capture packets, you must install the “ChmodBPF” launch daemon. You can do so by
opening the Install ChmodBPF.pkg file in the Wireshark .dmg or from Wireshark itself by opening
Wireshark › About Wireshark selecting the “Folders” tab, and double-clicking “macOS Extras”.
The installer package includes Wireshark along with ChmodBPF and system path packages. See the
included Read me first.html file for more details.

Installing the binaries under UNIX
In general installing the binary under your version of UNIX will be specific to the installation
methods used with your version of UNIX. For example, under AIX, you would use smit to install the
Wireshark binary package, while under Tru64 UNIX (formerly Digital UNIX) you would use setld.

19

Installing from RPMs under Red Hat and alike
Building RPMs from Wireshark’s source code results in several packages (most distributions follow
the same system):
• The wireshark package contains the core Wireshark libraries and command-line tools.
• The wireshark or wireshark-qt package contains the Qt-based GUI.
Many distributions use yum or a similar package management tool to make installation of software
(including its dependencies) easier. If your distribution uses yum, use the following command to
install Wireshark together with the Qt GUI:

yum install wireshark wireshark-qt
If you’ve built your own RPMs from the Wireshark sources you can install them by running, for
example:

rpm -ivh wireshark-2.0.0-1.x86_64.rpm wireshark-qt-2.0.0-1.x86_64.rpm
If the above command fails because of missing dependencies, install the dependencies first, and
then retry the step above.

Installing from debs under Debian, Ubuntu and other Debian derivatives
If you can just install from the repository then use

apt install wireshark
Apt should take care of all of the dependency issues for you.
Capturing requires privileges

NOTE

By installing Wireshark packages non-root, users won’t gain rights automatically to
capture packets. To allow non-root users to capture packets follow the procedure
described

in

https://gitlab.com/wireshark/wireshark/-/blob/master/packaging/

debian/README.Debian (/usr/share/doc/wireshark-common/README.Debian.gz)

Installing from portage under Gentoo Linux
Use the following command to install Wireshark under Gentoo Linux with all of the extra features:

USE="c-ares ipv6 snmp ssl kerberos threads selinux" emerge wireshark

20

Installing from packages under FreeBSD
Use the following command to install Wireshark under FreeBSD:

pkg_add -r wireshark
pkg_add should take care of all of the dependency issues for you.

Building from source under UNIX or Linux
We recommended using the binary installer for your platform unless you want to start developing
Wireshark.
Building Wireshark requires the proper build environment including a compiler and many
supporting libraries. For more information, see the Developer’s Guide at:
• https://www.wireshark.org/docs/wsdg_html_chunked/ChSrcObtain
• https://www.wireshark.org/docs/wsdg_html_chunked/ChapterSetup#ChSetupUNIX

Updating Wireshark
By default, Wireshark on Windows and macOS will check for new versions and notify you when
they are available. If you have the Check for updates preference disabled or if you run Wireshark in
an isolated environment you should subscribe to the wireshark-announce mailing list to be notified
of new versions. See Mailing Lists for details on subscribing to this list.
New versions of Wireshark are usually released every four to six weeks. Updating Wireshark is
done the same way as installing it. Simply download and run the installer on Windows, or
download and drag the application on macOS. A reboot is usually not required and all your
personal settings will remain unchanged.
We offer two update channels, Stable and Development. The Stable channel is the default, and only
installs packages from stable (even-numbered) release branches. The Development channel installs
development and release candidate packages when they are available, and stable releases
otherwise. To configure your release channel, go to Preferences › Advanced and search for
“update.channel”. See Preferences for details.

21

User Interface
Introduction
By now you have installed Wireshark and are likely keen to get started capturing your first packets.
In the next chapters we will explore:
• How the Wireshark user interface works
• How to capture packets in Wireshark
• How to view packets in Wireshark
• How to filter packets in Wireshark
• … and many other things!

Start Wireshark
You can start Wireshark from your shell or window manager.
Power user tip

TIP

When starting Wireshark it’s possible to specify optional settings using the command
line. See Start Wireshark from the command line for details.

The following chapters contain many screenshots of Wireshark. As Wireshark runs on many
different platforms with many different window managers, different styles applied and there are
different versions of the underlying GUI toolkit used, your screen might look different from the
provided screenshots. But as there are no real differences in functionality these screenshots should
still be well understandable.

The Main window
Let’s look at Wireshark’s user interface. The Main window shows Wireshark as you would usually
see it after some packets are captured or loaded (how to do this will be described later).

check the screen below
Figure 2. The Main window

Wireshark’s main window consists of parts that are commonly known from many other GUI
programs.
1. The menu (see The Menu) is used to start actions.
2. The main toolbar (see The “Main” Toolbar) provides quick access to frequently used items from
the menu.
3. The filter toolbar (see The “Filter” Toolbar) allows users to set display filters to filter which
packets are displayed (see Filtering Packets While Viewing).
4. The packet list pane (see The “Packet List” Pane) displays a summary of each packet captured. By
clicking on packets in this pane you control what is displayed in the other two panes.
5. The packet details pane (see The “Packet Details” Pane) displays the packet selected in the packet
list pane in more detail.
6. The packet bytes pane (see The “Packet Bytes” Pane) displays the data from the packet selected in
the packet list pane, and highlights the field selected in the packet details pane.
7. The packet diagram pane (see The “Packet Diagram” Pane) displays the packet selected in the
packet list as a textbook-style diagram.
8. The statusbar (see The Statusbar) shows some detailed information about the current program
state and the captured data.

23

TIP

The layout of the main window can be customized by changing preference settings.
See Preferences for details.

Main Window Navigation
Packet list and detail navigation can be done entirely from the keyboard. Keyboard Navigation
shows a list of keystrokes that will let you quickly move around a capture file. See Go menu items
for additional navigation keystrokes.
Table 2. Keyboard Navigation

Accelerator

Description

Tab or Shift + Tab

Move between screen elements, e.g., from the toolbars to the packet list to
the packet detail.

↓

Move to the next packet or detail item.

↑

Move to the previous packet or detail item.

Ctrl + ↓ or F8

Move to the next packet, even if the packet list isn’t focused.

Ctrl + ↑ or F7

Move to the previous packet, even if the packet list isn’t focused.

Ctrl + .

Move to the next packet of the conversation (TCP, UDP or IP).

Ctrl + ,

Move to the previous packet of the conversation (TCP, UDP or IP).

Alt + → or Option + →

Move to the next packet in the selection history.

(macOS)
Alt + ← or Option + ←

Move to the previous packet in the selection history.

(macOS)
←

In the packet detail, closes the selected tree item. If it’s already closed,
jumps to the parent node.

→

In the packet detail, opens the selected tree item.

Shift + →

In the packet detail, opens the selected tree item and all of its subtrees.

Ctrl + →

In the packet detail, opens all tree items.

Ctrl + ←

In the packet detail, closes all tree items.

Backspace

In the packet detail, jumps to the parent node.

Return or Enter

In the packet detail, toggles the selected tree item.

Help › About Wireshark › Keyboard Shortcuts will show a list of all shortcuts in the main
window. Additionally, typing anywhere in the main window will start filling in a display filter.

24

The Menu
Wireshark’s main menu is located either at the top of the main window (Windows, Linux) or at the
top of your main screen (macOS). An example is shown in The Menu.
Some menu items will be disabled (greyed out) if the corresponding feature isn’t
NOTE

available. For example, you cannot save a capture file if you haven’t captured or
loaded any packets.

check the screen below

Figure 3. The Menu

The main menu contains the following items:
File
This menu contains items to open and merge capture files, save, print, or export capture files in
whole or in part, and to quit the Wireshark application. See The “File” Menu.
Edit
This menu contains items to find a packet, time reference or mark one or more packets, handle
configuration profiles, and set your preferences; (cut, copy, and paste are not presently
implemented). See The “Edit” Menu.
View
This menu controls the display of the captured data, including colorization of packets, zooming
the font, showing a packet in a separate window, expanding and collapsing trees in packet
details, …. See The “View” Menu.
Go
This menu contains items to go to a specific packet. See The “Go” Menu.
Capture
This menu allows you to start and stop captures and to edit capture filters. See The “Capture”
Menu.
Analyze
This menu contains items to manipulate display filters, enable or disable the dissection of
protocols, configure user specified decodes and follow a TCP stream. See The “Analyze” Menu.
Statistics
This menu contains items to display various statistic windows, including a summary of the
packets that have been captured, display protocol hierarchy statistics and much more. See The
“Statistics” Menu.

25

Telephony
This menu contains items to display various telephony related statistic windows, including a
media analysis, flow diagrams, display protocol hierarchy statistics and much more. See The
“Telephony” Menu.
Wireless
This menu contains items to display Bluetooth and IEEE 802.11 wireless statistics.
Tools
This menu contains various tools available in Wireshark, such as creating Firewall ACL Rules.
See The “Tools” Menu.
Help
This menu contains items to help the user, e.g., access to some basic help, manual pages of the
various command line tools, online access to some of the webpages, and the usual about dialog.
See The “Help” Menu.
Each of these menu items is described in more detail in the sections that follow.
Shortcuts make life easier

TIP

Most common menu items have keyboard shortcuts. For example, you can press the
Control and the K keys together to open the “Capture Options” dialog.

The “File” Menu
The Wireshark file menu contains the fields shown in File menu items.

check the screen below

Figure 4. The “File” Menu

check the table below

Table 3. File menu items

Menu Item

Accelerator

Description

Open…

Ctrl + O

This shows the file open dialog box that allows
you to load a capture file for viewing. It is
discussed in more detail in The “Open Capture
File” Dialog Box.

Open Recent

This lets you open recently opened capture files.
Clicking on one of the submenu items will open
the corresponding capture file directly.

Merge…

This menu item lets you merge a capture file
into the currently loaded one. It is discussed in
more detail in Merging Capture Files.

Import from Hex Dump…

This menu item brings up the import file dialog
box that allows you to import a text file
containing a hex dump into a new temporary
capture. It is discussed in more detail in Import
Hex Dump.

27

Menu Item

Accelerator

Description

Close

Ctrl + W

This menu item closes the current capture. If
you haven’t saved the capture, you will be asked
to do so first (this can be disabled by a
preference setting).

Save

Ctrl + S

This menu item saves the current capture. If you
have not set a default capture file name
(perhaps with the -w <capfile> option),
Wireshark pops up the Save Capture File As
dialog box (which is discussed further in The
“Save Capture File As” Dialog Box).
If you have already saved the current capture,
this menu item will be greyed out.
You cannot save a live capture while the capture
is in progress. You must stop the capture in
order to save.

Save As…

Shift + Ctrl + S

This menu item allows you to save the current
capture file to whatever file you would like. It
pops up the Save Capture File As dialog box
(which is discussed further in The “Save Capture
File As” Dialog Box).

File Set › List Files

This menu item allows you to show a list of files
in a file set. It pops up the Wireshark List File Set
dialog box (which is discussed further in File
Sets).

File Set › Next File

If the currently loaded file is part of a file set,
jump to the next file in the set. If it isn’t part of a
file set or just the last file in that set, this item is
greyed out.

File Set › Previous File

If the currently loaded file is part of a file set,
jump to the previous file in the set. If it isn’t part
of a file set or just the first file in that set, this
item is greyed out.

Export Specified Packets…

This menu item allows you to export all (or
some) of the packets in the capture file to file. It
pops up the Wireshark Export dialog box (which
is discussed further in Exporting Data).

28

Menu Item

Accelerator

Description

Export Packet

Ctrl + H

These menu items allow you to export the

Dissections…

currently selected bytes in the packet bytes pane
to a text file in a number of formats including
plain, CSV, and XML. It is discussed further in
The “Export Selected Packet Bytes” Dialog Box.

Export Objects

These menu items allow you to export captured
DICOM, HTTP, IMF, SMB, or TFTP objects into
local files. It pops up a corresponding object list
(which is discussed further in The “Export
Objects” Dialog Box)

Print…

Ctrl + P

This menu item allows you to print all (or some)
of the packets in the capture file. It pops up the
Wireshark Print dialog box (which is discussed
further in Printing Packets).

Quit

Ctrl + Q

This menu item allows you to quit from
Wireshark. Wireshark will ask to save your
capture file if you haven’t previously saved it
(this can be disabled by a preference setting).

The “Edit” Menu
The Wireshark Edit menu contains the fields shown in Edit menu items.

check the screen below


Figure 5. The “Edit” Menu
Table 4. Edit menu items

Menu Item

Accelerator

Copy

Description
These menu items will copy the packet list,
packet detail, or properties of the currently
selected packet to the clipboard.

Find Packet…

Ctrl + F

This menu item brings up a toolbar that allows
you to find a packet by many criteria. There is
further information on finding packets in
Finding Packets.

Find Next

Ctrl + N

This menu item tries to find the next packet
matching the settings from “Find Packet…”.

Find Previous

Ctrl + B

This menu item tries to find the previous packet
matching the settings from “Find Packet…”.

Mark/Unmark Packet

Ctrl + M

This menu item marks the currently selected
packet. See Marking Packets for details.

Mark All Displayed Packets Ctrl + Shift + M

This menu item marks all displayed packets.

Unmark All Displayed

Ctrl + Alt + M

This menu item unmarks all displayed packets.

Ctrl + Shift + N

Find the next marked packet.

Packets
Next Mark

30

Menu Item

Accelerator

Description

Previous Mark

Ctrl + Shift + B

Find the previous marked packet.

Ignore/Unignore Packet

Ctrl + D

This menu item marks the currently selected
packet as ignored. See Ignoring Packets for
details.

Ignore All Displayed

Ctrl + Shift + D

This menu item marks all displayed packets as
ignored.

Unignore All Displayed

Ctrl + Alt + D

This menu item unmarks all ignored packets.

Set/Unset Time Reference

Ctrl + T

This menu item set a time reference on the
currently selected packet. See Packet Time
Referencing for more information about the
time referenced packets.

Unset All Time References

Ctrl + Alt + T

This menu item removes all time references on
the packets.

Next Time Reference

Ctrl + Alt + N

This menu item tries to find the next time
referenced packet.

Previous Time Reference

Ctrl + Alt + B

This menu item tries to find the previous time
referenced packet.

Time Shift…

Ctrl + Shift + T

Opens the “Time Shift” dialog, which allows you
to adjust the timestamps of some or all packets.

Packet Comment…

Ctrl + Alt + C

Opens the “Packet Comment” dialog, which lets
you add a comment to a single packet. Note that
the ability to save packet comments depends on
your file format. E.g., pcapng supports
comments, pcap does not.

Delete All Packet

This will delete all comments from all packets.

Comments

Note that the ability to save capture comments
depends on your file format. E.g., pcapng
supports comments, pcap does not.

Configuration Profiles…

Ctrl + Shift + A

This menu item brings up a dialog box for
handling configuration profiles. More detail is
provided in Configuration Profiles.

Preferences…

Ctrl + Shift + P or This menu item brings up a dialog box that
Cmd + , (macOS)

allows you to set preferences for many
parameters that control Wireshark. You can also
save your preferences so Wireshark will use
them the next time you start it. More detail is
provided in Preferences.

31

The “View” Menu
The Wireshark View menu contains the fields shown in View menu items.
check the screen below

Figure 6. The “View” Menu

check the table below

Table 5. View menu items

Menu Item
Main Toolbar

Accelerator

Description
This menu item hides or shows the main toolbar,
see The “Main” Toolbar.

Filter Toolbar

This menu item hides or shows the filter toolbar,
see The “Filter” Toolbar.

Wireless Toolbar

This menu item hides or shows the wireless
toolbar. May not be present on some platforms.

Statusbar

This menu item hides or shows the statusbar,
see The Statusbar.

Packet List

This menu item hides or shows the packet list
pane, see The “Packet List” Pane.

Packet Details

This menu item hides or shows the packet
details pane, see The “Packet Details” Pane.

Packet Bytes

This menu item hides or shows the packet bytes
pane, see The “Packet Bytes” Pane.

32

Menu Item
Packet Diagram

Accelerator

Description
This menu item hides or shows the packet
diagram pane. See The “Packet Diagram” Pane.

Time Display Format ›
Date and Time of Day:
1970-01-01 01:02:03.123456

Selecting this tells Wireshark to display the time
stamps in date and time of day format, see Time
Display Formats And Time References.
The fields “Time of Day”, “Date and Time of
Day”, “Seconds Since First Captured Packet”,
“Seconds Since Previous Captured Packet” and
“Seconds Since Previous Displayed Packet” are
mutually exclusive.

Time Display Format ›
Time of Day:

Selecting this tells Wireshark to display time
stamps in time of day format, see Time Display

01:02:03.123456

Formats And Time References.

Time Display Format ›

Selecting this tells Wireshark to display time

Seconds Since Epoch (1970-

stamps in seconds since 1970-01-01 00:00:00, see

01-01): 1234567890.123456

Time Display Formats And Time References.

Time Display Format ›

Selecting this tells Wireshark to display time

Seconds Since First
Captured Packet:

stamps in seconds since first captured packet
format, see Time Display Formats And Time

123.123456

References.

Time Display Format ›

Selecting this tells Wireshark to display time

Seconds Since Previous

stamps in seconds since previous captured

Captured Packet: 1.123456

packet format, see Time Display Formats And

Time Display Format ›

Selecting this tells Wireshark to display time

Seconds Since Previous

Time References.
stamps in seconds since previous displayed

Displayed Packet: 1.123456

packet format, see Time Display Formats And

Time Display Format ›

Selecting this tells Wireshark to display time

Automatic (File Format
Precision)

Time References.
stamps with the precision given by the capture
file format used, see Time Display Formats And
Time References.
The fields “Automatic”, “Seconds” and “…
seconds” are mutually exclusive.

Time Display Format ›
Seconds: 0

Selecting this tells Wireshark to display time
stamps with a precision of one second, see Time
Display Formats And Time References.

33

Menu Item

Accelerator

Time Display Format › …

Description
Selecting this tells Wireshark to display time
stamps with a precision of one second,

seconds: 0….

decisecond, centisecond, millisecond,
microsecond or nanosecond, see Time Display
Formats And Time References.

Time Display Format ›

Selecting this tells Wireshark to display time
stamps in seconds, with hours and minutes.

Display Seconds with
hours and minutes

This item allows you to trigger a name resolve of

Name Resolution › Resolve
Name

the current packet only, see Name Resolution.

Name Resolution › Enable

This item allows you to control whether or not

for MAC Layer

Wireshark translates MAC addresses into names,

Name Resolution › Enable

This item allows you to control whether or not

see Name Resolution.

for Network Layer

Wireshark translates network addresses into

Name Resolution › Enable

This item allows you to control whether or not

names, see Name Resolution.

for Transport Layer

Wireshark translates transport addresses into

Colorize Packet List

This item allows you to control whether or not

names, see Name Resolution.
Wireshark should colorize the packet list.
Enabling colorization will slow down the display
of new packets while capturing or loading
capture files.

Auto Scroll in Live Capture

This item allows you to specify that Wireshark
should scroll the packet list pane as new packets
come in, so you are always looking at the last
packet. If you do not specify this, Wireshark
simply adds new packets onto the end of the list,
but does not scroll the packet list pane.

Zoom In

Ctrl + +

Zoom into the packet data (increase the font
size).

Zoom Out

Ctrl + -

Zoom out of the packet data (decrease the font
size).

Normal Size

Ctrl + =

Set zoom level back to 100% (set font size back to
normal).

34

Menu Item

Accelerator

Description

Resize All Columns

Shift + Ctrl + R

Resize all column widths so the content will fit
into it.
Resizing may take a significant amount of time,
especially if a large capture file is loaded.

Displayed Columns

This menu items folds out with a list of all
configured columns. These columns can now be
shown or hidden in the packet list.

Expand Subtrees

Shift + →

This menu item expands the currently selected
subtree in the packet details tree.

Collapse Subtrees

Shift + ←

This menu item collapses the currently selected
subtree in the packet details tree.

Expand All

Ctrl + →

Wireshark keeps a list of all the protocol
subtrees that are expanded, and uses it to
ensure that the correct subtrees are expanded
when you display a packet. This menu item
expands all subtrees in all packets in the
capture.

Collapse All

Ctrl + ←

This menu item collapses the tree view of all
packets in the capture list.

Colorize Conversation

This menu item brings up a submenu that allows
you to color packets in the packet list pane based
on the addresses of the currently selected
packet. This makes it easy to distinguish packets
belonging to different conversations. Packet
colorization.

Colorize Conversation ›

These menu items enable one of the ten

Color 1-10

temporary color filters based on the currently

Colorize Conversation ›

This menu item clears all temporary coloring

selected conversation.

Reset coloring

rules.

Colorize Conversation ›

This menu item opens a dialog window in which

New Coloring Rule…

a new permanent coloring rule can be created

Coloring Rules…

This menu item brings up a dialog box that

based on the currently selected conversation.
allows you to color packets in the packet list
pane according to filter expressions you choose.
It can be very useful for spotting certain types of
packets, see Packet colorization.

35

Menu Item

Accelerator

Internals

Description
Information about various internal data
structures. See Internals menu items below for
more information.

Show Packet in New

Shows the selected packet in a separate window.

Window

The separate window shows only the packet
details and bytes. See Viewing a packet in a
separate window for details.

Reload

Ctrl + R

This menu item allows you to reload the current
capture file.

Table 6. Internals menu items

Menu Item

Description

Conversation Hash Tables

Shows the tuples (address and port combinations) used to
identify each conversation.

Dissector Tables

Shows tables of subdissector relationships.

Supported Protocols

Displays supported protocols and protocol fields.

The “Go” Menu
The Wireshark Go menu contains the fields shown in Go menu items.

check the screen below


Figure 7. The “Go” Menu

check the table below

Table 7. Go menu items

Menu Item

Accelerator

Description

Back

Alt + ←

Jump to the recently visited packet in the packet
history, much like the page history in a web
browser.

Forward

Alt + →

Jump to the next visited packet in the packet
history, much like the page history in a web
browser.

Go to Packet…

Ctrl + G

Bring up a window frame that allows you to
specify a packet number, and then goes to that
packet. See Go To A Specific Packet for details.

Go to Corresponding

Go to the corresponding packet of the currently

Packet

selected protocol field. If the selected field
doesn’t correspond to a packet, this item is
greyed out.

Previous Packet

Ctrl + ↑

Move to the previous packet in the list. This can
be used to move to the previous packet even if
the packet list doesn’t have keyboard focus.

37

Menu Item

Accelerator

Description

Next Packet

Ctrl + ↓

Move to the next packet in the list. This can be
used to move to the previous packet even if the
packet list doesn’t have keyboard focus.

First Packet

Ctrl + Home

Jump to the first packet of the capture file.

Last Packet

Ctrl + End

Jump to the last packet of the capture file.

Previous Packet In

Ctrl + ,

Move to the previous packet in the current

Conversation

conversation. This can be used to move to the
previous packet even if the packet list doesn’t
have keyboard focus.

Next Packet In

Ctrl + .

Conversation

Move to the next packet in the current
conversation. This can be used to move to the
previous packet even if the packet list doesn’t
have keyboard focus.

The “Capture” Menu
The Wireshark Capture menu contains the fields shown in Capture menu items.

check the screen below

Figure 8. The “Capture” Menu

check the table below

Table 8. Capture menu items



Menu Item

Accelerator

Description

Options…

Ctrl + K

Shows the Capture Options dialog box, which
allows you to configure interfaces and capture
options. See The “Capture Options” Dialog Box.

Start

Ctrl + E

Immediately starts capturing packets with the
same settings as the last time.

Stop

Ctrl + E

Stops the currently running capture. See Stop
the running capture.

Restart

Ctrl + R

Stops the currently running capture and starts it
again with the same options.

Capture Filters…

Shows a dialog box that allows you to create and
edit capture filters. You can name filters and
save them for future use. See Defining And
Saving Filters.

Refresh Interfaces

F5

Clear and recreate the interface list.

The “Analyze” Menu
The Wireshark Analyze menu contains the fields shown in Analyze menu items.

check the screen below


Figure 9. The “Analyze” Menu

check the table below

Table 9. Analyze menu items

Menu Item

Accelerator

Display Filters…

Description
Displays a dialog box that allows you to create
and edit display filters. You can name filters, and
you can save them for future use. See Defining
And Saving Filters.

Display Filter Macros…

Shows a dialog box that allows you to create and
edit display filter macros. You can name filter
macros, and you can save them for future use.
See Defining And Saving Filter Macros.

Apply as Column

Shift + Ctrl + I

Adds the selected protocol item in the packet
details pane as a column to the packet list.

Apply as Filter

Change the current display filter and apply it
immediately. Depending on the chosen menu
item, the current display filter string will be
replaced or appended to by the selected protocol
field in the packet details pane.

Prepare as Filter

Change the current display filter but won’t apply
it. Depending on the chosen menu item, the
current display filter string will be replaced or
appended to by the selected protocol field in the
packet details pane.

Conversation Filter
Enabled Protocols…

Apply a conversation filter for various protocols.
Shift + Ctrl + E

Enable or disable various protocol dissectors.
See The “Enabled Protocols” dialog box.

Decode As…

Decode certain packets as a particular protocol.
See User Specified Decodes.

Follow › TCP Stream

Open a window that displays all the TCP
segments captured that are on the same TCP
connection as a selected packet. See Following
Protocol Streams.

Follow › UDP Stream

Same functionality as “Follow TCP Stream” but

Follow › TLS Stream

Same functionality as “Follow TCP Stream” but

for UDP “streams”.
for TLS or SSL streams. See the wiki page on TLS
for instructions on providing TLS keys.

Follow › HTTP Stream

40

Same functionality as “Follow TCP Stream” but
for HTTP streams.

Menu Item

Accelerator

Expert Info

Description
Open a window showing expert information
found in the capture. Some protocol dissectors
add packet detail items for notable or unusual
behavior, such as invalid checksums or
retransmissions. Those items are shown here.
See Expert Information for more information.
The amount of information will vary depend on
the protocol

The “Statistics” Menu
The Wireshark Statistics menu contains the fields shown in Statistics menu items.

check the screen below


Figure 10. The “Statistics” Menu

Each menu item brings up a new window showing specific statistics.
Table 10. Statistics menu items

Menu Item
Capture File Properties

Accelerator

Description
Show information about the capture file, see The
“Capture File Properties” Dialog.

41

Menu Item

Accelerator

Description

Resolved Addresses

See Resolved Addresses

Protocol Hierarchy

Display a hierarchical tree of protocol statistics,
see The “Protocol Hierarchy” Window.

Conversations

Display a list of conversations (traffic between
two endpoints), see The “Conversations”
Window.

Endpoints

Display a list of endpoints (traffic to/from an
address), see The “Endpoints” Window.

Packet Lengths

See Packet Lengths

I/O Graphs

Display user specified graphs (e.g., the number
of packets in the course of time), see The “I/O
Graphs” Window.

Service Response Time

Display the time between a request and the
corresponding response, see Service Response
Time.

DHCP (BOOTP)

See DHCP (BOOTP) Statistics

NetPerfMeter

See NetPerfMeter Statistics

ONC-RPC Programs

See ONC-RPC Programs

29West

See 29West

ANCP

See ANCP

BACnet

See BACnet

Collectd

See Collectd

DNS

See DNS

Flow Graph

See Flow Graph

HART-IP

See HART-IP

HPFEEDS

See HPFEEDS

HTTP

HTTP request/response statistics, see HTTP
Statistics

HTTP2

See HTTP2

Sametime

See Sametime

TCP Stream Graphs

See TCP Stream Graphs

UDP Multicast Streams

See UDP Multicast Streams

Reliable Server Pooling

See Reliable Server Pooling (RSerPool)

(RSerPool)

42

Menu Item

Accelerator

Description

F5

See F5

IPv4 Statistics

See IPv4 Statistics

IPv6 Statistics

See IPv6 Statistics

The “Telephony” Menu
The Wireshark Telephony menu contains the fields shown in Telephony menu items.

check the screen below


Figure 11. The “Telephony” Menu

Each menu item shows specific telephony related statistics.

check the table below

Table 11. Telephony menu items

Menu Item

Accelerator

Description

VoIP Calls…

See VoIP Calls Window

ANSI

See ANSI

GSM

See GSM Windows

IAX2 Stream Analysis

See IAX2 Stream Analysis Window

ISUP Messages

See ISUP Messages Window

43

Menu Item

Accelerator

Description

LTE

See LTE

MTP3

See MTP3 Windows

Osmux

See Osmux Windows

RTP

See RTP Streams Window and RTP Stream
Analysis Window

RTSP

See RTSP Window

SCTP

See SCTP Windows

SMPP Operations

See SMPP Operations Window

UCP Messages

See UCP Messages Window

H.225

See H.225 Window

SIP Flows

See SIP Flows Window

SIP Statistics

See SIP Statistics Window

WAP-WSP Packet Counter

See WAP-WSP Packet Counter Window

The “Wireless” Menu
The Wireless menu lets you analyze Bluetooth and IEEE 802.11 wireless LAN activity as shown in
The “Wireless” Menu.

check the screen below

Figure 12. The “Wireless” Menu

Each menu item shows specific Bluetooth and IEEE 802.11 statistics.

check the table below

Table 12. Wireless menu items

Menu Item

Accelerator

Bluetooth ATT Server

Description
See Bluetooth ATT Server Attributes

Attributes
Bluetooth Devices

See Bluetooth Devices

Bluetooth HCI Summary

See Bluetooth HCI Summary

WLAN Traffic

See WLAN Traffic

The “Tools” Menu
The Wireshark Tools menu contains the fields shown in Tools menu items.

check the screen below

Figure 13. The “Tools” Menu

check the table below

Table 13. Tools menu items

Menu Item
Firewall ACL Rules

Accelerator

Description
This allows you to create command-line ACL
rules for many different firewall products,
including Cisco IOS, Linux Netfilter (iptables),
OpenBSD pf and Windows Firewall (via netsh).
Rules for MAC addresses, IPv4 addresses, TCP
and UDP ports, and IPv4+port combinations are
supported.
It is assumed that the rules will be applied to an
outside interface.
Menu item is greyed out unless one (and only
one) frame is selected in the packet list.

46

Menu Item

Accelerator

Credentials

Description
This allows you to extract credentials from the
current capture file. Some of the dissectors (ftp,
http, imap, pop, smtp) have been instrumented
to provide the module with usernames and
passwords and more will be instrumented in the
future. The window dialog provides you the
packet number where the credentials have been
found, the protocol that provided them, the
username and protocol specific information.

Lua

These options allow you to work with the Lua
interpreter optionally built into Wireshark. See
“Lua Support in Wireshark” in the Wireshark
Developer’s Guide.
The Lua menu structure is set by console.lua in
the Wireshark install directory.

The “Help” Menu
The Wireshark Help menu contains the fields shown in Help menu items.

check the screen below


Figure 14. The “Help” Menu

check the table below

Table 14. Help menu items

Menu Item

Accelerator

Description

Contents

F1

This menu item brings up a basic help system.

Manual Pages › …

This menu item starts a Web browser showing

Website

This menu item starts a Web browser showing

one of the locally installed html manual pages.
the webpage from: https://www.wireshark.org/.

FAQs

This menu item starts a Web browser showing
various FAQs.

Downloads

This menu item starts a Web browser showing
the downloads from: https://www.wireshark.org/
download.html.

Wiki

This menu item starts a Web browser showing
the front page from: https://gitlab.com/
wireshark/wireshark/-/wikis/.

Sample Captures

This menu item starts a Web browser showing
the sample captures from: https://gitlab.com/
wireshark/wireshark/-/wikis/SampleCaptures.

About Wireshark

This menu item brings up an information
window that provides various detailed
information items on Wireshark, such as how
it’s built, the plugins loaded, the used folders, …

Opening a Web browser might be unsupported in your version of Wireshark. If this
is the case the corresponding menu items will be hidden.
NOTE

If calling a Web browser fails on your machine, nothing happens, or the browser
starts but no page is shown, have a look at the web browser setting in the
preferences dialog.

The “Main” Toolbar
The main toolbar provides quick access to frequently used items from the menu. This toolbar
cannot be customized by the user, but it can be hidden using the View menu if the space on the
screen is needed to show more packet data.
Items in the toolbar will be enabled or disabled (greyed out) similar to their corresponding menu
items. For example, in the image below shows the main window toolbar after a file has been
opened. Various file-related buttons are enabled, but the stop capture button is disabled because a
capture is not in progress.

check the screen below
Figure 15. The “Main” toolbar

check the table below

Table 15. Main toolbar items

Toolbar

Toolbar Item

Menu Item

Description

[ Start ]

Capture › Start

Starts capturing packets with the same

Icon
options as the last capture or the default
options if none were set (Start Capturing).
Capture › Stop

Stops the currently running capture (Start

[ Restart ]

Capture › Restart

Restarts the current capture session.

[ Options… ]

Capture › Options… Opens the “Capture Options” dialog box.
See Start Capturing for details.

[ Open… ]

File › Open…

[ Stop ]

Capturing).

Opens the file open dialog box, which
allows you to load a capture file for
viewing. It is discussed in more detail in
The “Open Capture File” Dialog Box.

[ Save As… ]

File › Save As…

Save the current capture file to whatever
file you would like. See The “Save Capture
File As” Dialog Box for details. If you
currently have a temporary capture file
open the “Save” icon will be shown
instead.

[ Close ]

File › Close

Closes the current capture. If you have not
saved the capture, you will be asked to
save it first.

[ Reload ]

View › Reload

Reloads the current capture file.

[ Find Packet… ]

Edit › Find Packet… Find a packet based on different criteria.
See Finding Packets for details.

[ Go Back ]

Go › Go Back

Jump back in the packet history. Hold
down the Alt key ( Option on macOS) to go
back in the selection history.

[ Go Forward ]

Go › Go Forward

Jump forward in the packet history. Hold
down the Alt key ( Option on macOS) to go
forward in the selection history.

[ Go to Packet… ]

Go › Go to Packet…

Go to a specific packet.

49

Toolbar

Toolbar Item

Menu Item

Description

[ Go To First

Go › First Packet

Jump to the first packet of the capture file.

Go › Last Packet

Jump to the last packet of the capture file.

Icon
Packet ]
[ Go To Last
Packet ]

[ Auto Scroll in Live View › Auto Scroll

Auto scroll packet list while doing a live

Capture ]

in Live Capture

capture (or not).

[ Colorize ]

View › Colorize

Colorize the packet list (or not).

[ Zoom In ]

View › Zoom In

Zoom into the packet data (increase the

View › Zoom Out

Zoom out of the packet data (decrease the

[ Normal Size ]

View › Normal Size

Set zoom level back to 100%.

[ Resize Columns ]

View › Resize

Resize columns, so the content fits into

[ Zoom Out ]

Columns

font size).
font size).

them.

The “Filter” Toolbar
The filter toolbar lets you quickly edit and apply display filters. More information on display filters
is available in Filtering Packets While Viewing.

check the screen below


Figure 16. The “Filter” toolbar

check the table below

Table 16. Filter toolbar items

Toolbar

Name

Description

Bookmarks

Manage or select saved filters.

Icon

50

Toolbar

Name

Description

Filter Input

The area to enter or edit a display filter string, see

Icon
Building Display Filter Expressions. A syntax check of
your filter string is done while you are typing. The
background will turn red if you enter an incomplete
or invalid string, and will become green when you
enter a valid string.
After you’ve changed something in this field, don’t
forget to press the Apply button (or the Enter/Return
key), to apply this filter string to the display.
This field is also where the current applied filter is
displayed.
Clear

Reset the current display filter and clear the edit area.

Apply

Apply the current value in the edit area as the new
display filter.
Applying a display filter on large capture files might
take quite a long time.

Recent

Select from a list of recently applied filters.

Add Button

Add a new filter button.

[ Squirre Filter Button

Filter buttons are handy shortcuts that apply a display

ls ]

filter as soon as you press them. You can create filter
buttons by pressing the [ + ] button, right-clicking in
the filter button area, or opening the Filter Button
section of the Preferences Dialog. The example shows
a filter button with the label “Squirrels”. If you have
lots of buttons you can arrange them into groups by
using “//” as a label separator. For example, if you
create buttons named “Not Squirrels // Rabbits” and
“Not Squirrels // Capybaras” they will show up in the
toolbar under a single button named “Not Squirrels”.

The “Packet List” Pane
The packet list pane displays all the packets in the current capture file.

check the screen below
Figure 17. The “Packet List” pane

Each line in the packet list corresponds to one packet in the capture file. If you select a line in this
pane, more details will be displayed in the “Packet Details” and “Packet Bytes” panes.
While dissecting a packet, Wireshark will place information from the protocol dissectors into the
columns. As higher-level protocols might overwrite information from lower levels, you will
typically see the information from the highest possible level only.
For example, let’s look at a packet containing TCP inside IP inside an Ethernet packet. The Ethernet
dissector will write its data (such as the Ethernet addresses), the IP dissector will overwrite this by
its own (such as the IP addresses), the TCP dissector will overwrite the IP information, and so on.
There are many different columns available. You can choose which columns are displayed in the
preferences. See Preferences.
The default columns will show:
• [ No. ] The number of the packet in the capture file. This number won’t change, even if a display
filter is used.
• [ Time ] The timestamp of the packet. The presentation format of this timestamp can be
changed, see Time Display Formats And Time References.
• [ Source ] The address where this packet is coming from.
• [ Destination ] The address where this packet is going to.
• [ Protocol ] The protocol name in a short (perhaps abbreviated) version.
• [ Length ] The length of each packet.
• [ Info ] Additional information about the packet content.
The first column shows how each packet is related to the selected packet. For example, in the image
above the first packet is selected, which is a DNS request. Wireshark shows a rightward arrow for
the request itself, followed by a leftward arrow for the response in packet 2. Why is there a dashed
line? There are more DNS packets further down that use the same port numbers. Wireshark treats
them as belonging to the same conversation and draws a line connecting them.
Related packet symbols

First packet in a conversation.

52

Part of the selected conversation.
Not part of the selected conversation.
Last packet in a conversation.
Request.
Response.
The selected packet acknowledges this packet.
The selected packet is a duplicate acknowledgement of this packet.
The selected packet is related to this packet in some other way, e.g., as
part of reassembly.
The packet list has an Intelligent Scrollbar which shows a miniature map of nearby packets. Each
raster line of the scrollbar corresponds to a single packet, so the number of packets shown in the
map depends on your physical display and the height of the packet list. A tall packet list on a highresolution (“Retina”) display will show you quite a few packets. In the image above the scrollbar
shows the status of more than 500 packets along with the 15 shown in the packet list itself.
Right clicking will show a context menu, described in Pop-up menu of the “Packet List” pane.

The “Packet Details” Pane
The packet details pane shows the current packet (selected in the “Packet List” pane) in a more
detailed form.

check the screen below


Figure 18. The “Packet Details” pane

This pane shows the protocols and protocol fields of the packet selected in the “Packet List” pane.

53

The protocol summary lines (subtree labels) and fields of the packet are shown in a tree which can
be expanded and collapsed.
There is a context menu (right mouse click) available. See details in Pop-up menu of the “Packet
Details” pane.
Some protocol fields have special meanings.
• Generated fields. Wireshark itself will generate additional protocol information which isn’t
present in the captured data. This information is enclosed in square brackets (“[” and “]”).
Generated information includes response times, TCP analysis, IP geolocation information, and
checksum validation.
• Links. If Wireshark detects a relationship to another packet in the capture file it will generate a
link to that packet. Links are underlined and displayed in blue. If you double-clicked on a link
Wireshark will jump to the corresponding packet.

The “Packet Bytes” Pane
The packet bytes pane shows the data of the current packet (selected in the “Packet List” pane) in a
hexdump style.

check the screen below


Figure 19. The “Packet Bytes” pane

The “Packet Bytes” pane shows a canonical hex dump of the packet data. Each line contains the data
offset, sixteen hexadecimal bytes, and sixteen ASCII bytes. Non-printable bytes are replaced with a
period (“.”).
Depending on the packet data, sometimes more than one page is available, e.g. when Wireshark has
reassembled some packets into a single chunk of data. (See Packet Reassembly for details). In this
case you can see each data source by clicking its corresponding tab at the bottom of the pane.
The default mode for viewing will highlight the bytes for a field where the mouse pointer is
hovering above. The highlight will follow the mouse cursor as it moves. If this highlighting is not
required or wanted, there are two methods for deactivating the functionality:
• Temporary By holding down the Ctrl button while moving the mouse, the highlighted field will
not change
• Permanently Using the context menu (right mouse click) the hover highlighting may be
activated/deactivated. This setting is stored in the selected profile recent file.

54

check the screen below

Figure 20. The “Packet Bytes” pane with tabs

Additional tabs typically contain data reassembled from multiple packets or decrypted data.

The “Packet Diagram” Pane
The packet diagram pane shows the current packet (selected in the “Packet List” pane) as a
diagram, similar to ones used in textbooks and IETF RFCs.

Figure 21. The “Packet Diagram” pane

This pane shows the protocols and top-level protocol fields of the packet selected in the “Packet
List” pane as a series of diagrams.
There is a context menu (right mouse click) available. For details see Pop-up menu of the “Packet
Diagram” pane.

The Statusbar
The statusbar displays informational messages.

55

In general, the left side will show context related information, the middle part will show
information about the current capture file, and the right side will show the selected configuration
profile. Drag the handles between the text areas to change the size.
check the screen below


Figure 22. The initial Statusbar

This statusbar is shown while no capture file is loaded, e.g., when Wireshark is started.

check the screen below


Figure 23. The Statusbar with a loaded capture file

The colorized bullet…
on the left shows the highest expert information level found in the currently loaded capture file.
Hovering the mouse over this icon will show a description of the expert info level, and clicking
the icon will bring up the Expert Information dialog box. For a detailed description of this dialog
and each expert level, see Expert Information.
The edit icon…
on the left side lets you add a comment to the capture file using the Capture File Properties
dialog.
The left side…
shows the capture file name by default. It also shows field information when hovering over and
selecting items in the packet detail and packet bytes panes, as well as general notifications.
The middle…
shows the current number of packets in the capture file. The following values are displayed:
Packets
The number of captured packets.
Displayed
The number of packets currently being displayed.
Marked
The number of marked packets. Only displayed if you marked any packets.
Dropped
The number of dropped packets Only displayed if Wireshark was unable to capture all
packets.
Ignored
The number of ignored packets Only displayed if you ignored any packets.

56

The right side…
shows the selected configuration profile. Clicking on this part of the statusbar will bring up a
menu with all available configuration profiles, and selecting from this list will change the
configuration profile.

check the screen below


Figure 24. The Statusbar with a configuration profile menu

For a detailed description of configuration profiles, see Configuration Profiles.

check the screen below


Figure 25. The Statusbar with a selected protocol field

This is displayed if you have selected a protocol field in the “Packet Details” pane.
The value between the parentheses (in this example “ipv6.src”) is the display filter
TIP

field for the selected item. You can become more familiar with display filter fields by
selecting different packet detail items.

check the screen below


Figure 26. The Statusbar with a display filter message

This is displayed if you are trying to use a display filter which may have unexpected results.

57

Capturing Live Network Data
Introduction
Capturing live network data is one of the major features of Wireshark.
The Wireshark capture engine provides the following features:
• Capture from different kinds of network hardware such as Ethernet or 802.11.
• Simultaneously capture from multiple network interfaces.
• Stop the capture on different triggers such as the amount of captured data, elapsed time, or the
number of packets.
• Simultaneously show decoded packets while Wireshark is capturing.
• Filter packets, reducing the amount of data to be captured. See Filtering while capturing.
• Save packets in multiple files while doing a long-term capture, optionally rotating through a
fixed number of files (a “ringbuffer”). See Capture files and file modes.
The capture engine still lacks the following features:
• Stop capturing (or perform some other action) depending on the captured data.

Prerequisites
Setting up Wireshark to capture packets for the first time can be tricky. A comprehensive guide
“How To setup a Capture” is available at https://gitlab.com/wireshark/wireshark/-/wikis/
CaptureSetup.
Here are some common pitfalls:
• You may need special privileges to start a live capture.
• You need to choose the right network interface to capture packet data from.
• You need to capture at the right place in the network to see the traffic you want to see.
If you have any problems setting up your capture environment, you should have a look at the guide
mentioned above.

Start Capturing
The following methods can be used to start capturing packets with Wireshark:
• You can double-click on an interface in the welcome screen.
• You can select an interface in the welcome screen, then select Capture › Start or click the first
58

toolbar button.
• You can get more detailed information about available interfaces using The “Capture Options”
Dialog Box (Capture › Options…).
• If you already know the name of the capture interface you can start Wireshark from the
command line:

$ wireshark -i eth0 -k
This will start Wireshark capturing on interface eth0. More details can be found at Start Wireshark
from the command line.

The “Capture” Section Of The Welcome Screen
When you open Wireshark without starting a capture or opening a capture file it will display the
“Welcome Screen,” which lists any recently opened capture files and available capture interfaces.
Network activity for each interface will be shown in a sparkline next to the interface name. It is
possible to select more than one interface and capture from them simultaneously.

check the screen below


Figure 27. Capture interfaces on Microsoft Windows

Figure 28. Capture interfaces on macOS

Some interfaces allow or require configuration prior to capture. This will be indicated by a
configuration icon (

) to the left of the interface name. Clicking on the icon will show the

configuration dialog for that interface.
Hovering over an interface will show any associated IPv4 and IPv6 addresses and its capture filter.
Wireshark isn’t limited to just network interfaces — on most systems you can also capture USB,
59

Bluetooth, and other types of packets. Note also that an interface might be hidden if it’s inaccessible
to Wireshark or if it has been hidden as described in The “Manage Interfaces” Dialog Box.

The “Capture Options” Dialog Box
When you select Capture › Options… (or use the corresponding item in the main toolbar),
Wireshark pops up the “Capture Options” dialog box as shown in The “Capture Options” input tab.
If you are unsure which options to choose in this dialog box, leaving the defaults settings as they
are should work well in many cases.

check the screen below


Figure 29. The “Capture Options” input tab

The “Input” tab contains the “Interface” table, which shows the following columns:
Interface
The interface name.
Some interfaces allow or require configuration prior to capture. This will be indicated by a
configuration icon (

) to the left of the interface name. Clicking on the icon will show the

configuration dialog for that interface.
Traffic
A sparkline showing network activity over time.
Link-layer Header
The type of packet captured by this interface. In some cases it is possible to change this. See Linklayer header type for more details.
Promiscuous
Lets you put this interface in promiscuous mode while capturing. Note that another application
might override this setting.

60

Snaplen
The snapshot length, or the number of bytes to capture for each packet. You can set an explicit
length if needed, e.g., for performance or privacy reasons.
Buffer
The size of the kernel buffer that is reserved for capturing packets. You can increase or decrease
this as needed, but the default is usually sufficient.
Monitor Mode
Lets you capture full, raw 802.11 headers. Support depends on the interface type, hardware,
driver, and OS. Note that enabling this might disconnect you from your wireless network.
Capture Filter
The capture filter applied to this interface. You can edit the filter by double-clicking on it. See
Filtering while capturing for more details about capture filters.
Hovering over an interface or expanding it will show any associated IPv4 and IPv6 addresses.
If “Enable promiscuous mode on all interfaces” is enabled, the individual promiscuous mode
settings above will be overridden.
“Capture filter for selected interfaces” can be used to set a filter for more than one interface at the
same time.
[ Manage Interfaces ] opens the The “Manage Interfaces” dialog box where pipes can be defined,
local interfaces scanned or hidden, or remote interfaces added.
[ Compile Selected BPFs ] opens The “Compiled Filter Output” dialog box, which shows you the
compiled bytecode for your capture filter. This can help to better understand the capture filter you
created.
Linux power user tip

The execution of BPFs can be sped up on Linux by turning on BPF Just In Time
compilation by executing
TIP

$ echo 1 >/proc/sys/net/core/bpf_jit_enable
if it is not enabled already. To make the change persistent you can use sysfsutils.

61

Figure 30. The “Capture Options” output tab

The “Output” tab shows the following information:
Capture to a permanent file
File
This field allows you to specify the file name that will be used for the capture file. It is left
blank by default. If left blank, the capture data will be stored in a temporary file. See Capture
files and file modes for details. You can also click on the button to the right of this field to
browse through the filesystem.
Output format
Allows you to set the format of the capture file. pcapng is the default and is more flexible than
pcap. pcapng might be required, e.g., if more than one interface is chosen for capturing. See
https://gitlab.com/wireshark/wireshark/-/wikis/Development/PcapNg for more details on
pcapng.
Create a new file automatically…
Sets the conditions for switching a new capture file. A new capture file can be created based on
the following conditions:
• The number of packets in the capture file.
• The size of the capture file.
• The duration of the capture file.
• The wall clock time.
Use a ring buffer with
Multiple files only. Form a ring buffer of the capture files with the given number of files.
More details about capture files can be found in Capture files and file modes.

check the screen below


Figure 31. The “Capture Options” options tab

The “Options” tab shows the following information:
Display Options
Update list of packets in real-time
Updates the packet list pane in real time during capture. If you do not enable this, Wireshark
will not display any packets until you stop the capture. When you check this, Wireshark
captures in a separate process and feeds the captures to the display process.
Automatically scroll during live capture
Scroll the packet list pane as new packets come in, so you are always looking at the most
recent packet. If you do not specify this Wireshark adds new packets to the packet list but
does not scroll the packet list pane. This option is greyed out if “Update list of packets in realtime” is disabled.
Show capture information during capture
If this option is enabled, the capture information dialog described in While a Capture is
running … will be shown while packets are captured.
Name Resolution
Resolve MAC addresses
Translate MAC addresses into names.
Resolve network names
Translate network addresses into names.
Resolve transport names
Translate transport names (port numbers).
See Name Resolution for more details on each of these options.

63

Stop capture automatically after…
Capturing can be stopped based on the following conditions:
• The number of packets in the capture file.
• The number of capture files.
• The capture file size.
• The capture file duration.
You can double click on an interface row in the “Input“ tab or click [ Start ] from any tab to
commence the capture. You can click [ Cancel ] to apply your changes and close the dialog.

The “Manage Interfaces” Dialog Box

check the screen below


Figure 32. The “Manage Interfaces” dialog box

The “Manage Interfaces” dialog box initially shows the “Local Interfaces” tab, which lets you
manage the following:
Show
Whether or not to show or hide this interface in the welcome screen and the “Capture Options”
dialog.
Friendly Name
A name for the interface that is human readable.
Interface Name
The device name of the interface.

64

Comment
Can be used to add a descriptive comment for the interface.
The “Pipes” tab lets you capture from a named pipe. To successfully add a pipe, its associated
named pipe must have already been created. Click [ + ] and type the name of the pipe including its
path. Alternatively, [ Browse ] can be used to locate the pipe.
To remove a pipe from the list of interfaces, select it and press [ - ].
On Microsoft Windows, the “Remote Interfaces” tab lets you capture from an interface on a
different machine. The Remote Packet Capture Protocol service must first be running on the target
platform before Wireshark can connect to it.
On Linux or Unix you can capture (and do so more securely) through an SSH tunnel.
To add a new remote capture interface, click [ + ] and specify the following:
Host
The IP address or host name of the target platform where the Remote Packet Capture Protocol
service is listening. The drop-down list contains the hosts that have previously been successfully
contacted. The list can be emptied by choosing “Clear list” from the drop-down list.
Port
Set the port number where the Remote Packet Capture Protocol service is listening on. Leave
blank to use the default port (2002).
Null authentication
Select this if you don’t need authentication to take place for a remote capture to be started. This
depends on the target platform. This is exactly as secure as it appears, i.e., it is not secure at all.
Password authentication
Lets you specify the username and password required to connect to the Remote Packet Capture
Protocol service.
Each interface can optionally be hidden. In contrast to the local interfaces, they are not saved in the
preferences file.
NOTE

Make sure you have outside access to port 2002 on the target platform. This is the
default port used by the Remote Packet Capture Protocol service.

To remove a host including all its interfaces from the list, select it and click the [ - ] button.

The “Compiled Filter Output” Dialog Box
This figure shows the results of compiling the BPF filter for the selected interfaces.

check the screen below

Figure 33. The “Compiled Filter Output” dialog box

In the list on the left the interface names are listed. The results of compiling a filter for the selected
interface are shown on the right.

Capture files and file modes
While capturing, the underlying libpcap capturing engine will grab the packets from the network
card and keep the packet data in a (relatively) small kernel buffer. This data is read by Wireshark
and saved into a capture file.
By default, Wireshark saves packets to a temporary file. You can also tell Wireshark to save to a
specific (“permanent”) file and switch to a different file after a given time has elapsed or a given
number of packets have been captured. These options are controlled in the “Capture Options”
dialog’s “Output” tab.

check the screen below

Figure 34. Capture output options

Working with large files (several hundred MB) can be quite slow. If you plan to do a
TIP

long-term capture or capturing from a high traffic network, think about using one of
the “Multiple files” options. This will spread the captured packets over several smaller
files which can be much more pleasant to work with.

Using the “Multiple files” option may cut context related information. Wireshark keeps context
information of the loaded packet data, so it can report context related problems (like a stream
error) and keeps information about context related protocols (e.g., where data is exchanged at the
establishing phase and only referred to in later packets). As it keeps this information only for the
loaded file, using one of the multiple file modes may cut these contexts. If the establishing phase is
saved in one file and the things you would like to see is in another, you might not see some of the
valuable context related information.
Information about the folders used for capture files can be found in Files and Folders.
Table 17. Capture file mode selected by capture options

File Name
-

“Create a

“Use a ring

new file…”

buffer…”

-

-

Mode

Resulting filename(s) used

Single temporary

wiresharkXXXXXX (where

file

XXXXXX is a unique number)

foo.cap

-

-

Single named file

foo.cap

foo.cap

x

-

Multiple files,

foo_00001_20230714110102.cap,

continuous

foo_00002_20230714110318.cap, …

Multiple files, ring

foo_00001_20230714110102.cap,

buffer

foo_00002_20230714110318.cap, …

foo.cap

x

x

Single temporary file
A temporary file will be created and used (this is the default). After capturing is stopped this file
can be saved later under a user specified name.
Single named file
A single capture file will be used. Choose this mode if you want to place the new capture file in a
specific folder.
Multiple files, continuous
Like the “Single named file” mode, but a new file is created and used after reaching one of the
multiple file switch conditions (one of the “Next file every…” values).
Multiple files, ring buffer
Much like “Multiple files continuous”, reaching one of the multiple files switch conditions (one
of the “Next file every …” values) will switch to the next file. This will be a newly created file if
value of “Ring buffer with n files” is not reached, otherwise it will replace the oldest of the
formerly used files (thus forming a “ring”).

67

This mode will limit the maximum disk usage, even for an unlimited amount of capture input
data, only keeping the latest captured data.

Link-layer header type
In most cases you won’t have to modify link-layer header type. Some exceptions are as follows:
If you are capturing on an Ethernet device you might be offered a choice of “Ethernet” or “DOCSIS”.
If you are capturing traffic from a Cisco Cable Modem Termination System that is putting DOCSIS
traffic onto the Ethernet to be captured, select “DOCSIS”, otherwise select “Ethernet”.
If you are capturing on an 802.11 device on some versions of BSD you might be offered a choice of
“Ethernet” or “802.11”. “Ethernet” will cause the captured packets to have fake (“cooked”) Ethernet
headers. “802.11” will cause them to have full IEEE 802.11 headers. Unless the capture needs to be
read by an application that doesn’t support 802.11 headers you should select “802.11”.
If you are capturing on an Endace DAG card connected to a synchronous serial line you might be
offered a choice of “PPP over serial” or “Cisco HDLC”. If the protocol on the serial line is PPP, select
“PPP over serial” and if the protocol on the serial line is Cisco HDLC, select “Cisco HDLC”.
If you are capturing on an Endace DAG card connected to an ATM network you might be offered a
choice of “RFC 1483 IP-over-ATM” or “Sun raw ATM”. If the only traffic being captured is RFC 1483
LLC-encapsulated IP, or if the capture needs to be read by an application that doesn’t support
SunATM headers, select “RFC 1483 IP-over-ATM”, otherwise select “Sun raw ATM”.

Filtering while capturing
Wireshark supports limiting the packet capture to packets that match a capture filter. Wireshark
capture filters are written in libpcap filter language. Below is a brief overview of the libpcap filter
language’s syntax. Complete documentation can be found at the pcap-filter man page. You can find
many Capture Filter examples at https://gitlab.com/wireshark/wireshark/-/wikis/CaptureFilters.
You enter the capture filter into the “Filter” field of the Wireshark “Capture Options” dialog box, as
shown in The “Capture Options” input tab.
A capture filter takes the form of a series of primitive expressions connected by conjunctions
(and/or) and optionally preceded by not:

[not] primitive [and|or [not] primitive ...]
An example is shown in A capture filter for telnet that captures traffic to and from a particular host.

68

Example 1. A capture filter for telnet that captures traffic to and from a particular host

tcp port 23 and host 10.0.0.5

This example captures telnet traffic to and from the host 10.0.0.5, and shows how to use two
primitives and the and conjunction. Another example is shown in Capturing all telnet traffic not
from 10.0.0.5, and shows how to capture all telnet traffic except that from 10.0.0.5.
Example 2. Capturing all telnet traffic not from 10.0.0.5

tcp port 23 and not src host 10.0.0.5

A primitive is simply one of the following: [src|dst] host <host>
This primitive allows you to filter on a host IP address or name. You can optionally precede the
primitive with the keyword src|dst to specify that you are only interested in source or
destination addresses. If these are not present, packets where the specified address appears as
either the source or the destination address will be selected.
ether [src|dst] host <ehost>
This primitive allows you to filter on Ethernet host addresses. You can optionally include the
keyword src|dst between the keywords ether and host to specify that you are only interested in
source or destination addresses. If these are not present, packets where the specified address
appears in either the source or destination address will be selected.
gateway host <host>
This primitive allows you to filter on packets that used host as a gateway. That is, where the
Ethernet source or destination was host but neither the source nor destination IP address was
host.
[src|dst] net <net> [{mask <mask>}|{len <len>}]
This primitive allows you to filter on network numbers. You can optionally precede this
primitive with the keyword src|dst to specify that you are only interested in a source or
destination network. If neither of these are present, packets will be selected that have the
specified network in either the source or destination address. In addition, you can specify either
the netmask or the CIDR prefix for the network if they are different from your own.
[tcp|udp] [src|dst] port <port>
This primitive allows you to filter on TCP and UDP port numbers. You can optionally precede this
primitive with the keywords src|dst and tcp|udp which allow you to specify that you are only
interested in source or destination ports and TCP or UDP packets respectively. The keywords
tcp|udp must appear before src|dst.

69

If these are not specified, packets will be selected for both the TCP and UDP protocols and when
the specified address appears in either the source or destination port field.
less|greater <length>
This primitive allows you to filter on packets whose length was less than or equal to the
specified length, or greater than or equal to the specified length, respectively.
ip|ether proto <protocol>
This primitive allows you to filter on the specified protocol at either the Ethernet layer or the IP
layer.
ether|ip broadcast|multicast
This primitive allows you to filter on either Ethernet or IP broadcasts or multicasts.
<expr> relop <expr>
This primitive allows you to create complex filter expressions that select bytes or ranges of bytes
in packets. Please see the pcap-filter man page at https://www.tcpdump.org/manpages/pcapfilter.7.html for more details.

Automatic Remote Traffic Filtering
If Wireshark is running remotely (using e.g., SSH, an exported X11 window, a terminal server, …),
the remote content has to be transported over the network, adding a lot of (usually unimportant)
packets to the actually interesting traffic.
To avoid this, Wireshark tries to figure out if it’s remotely connected (by looking at some specific
environment variables) and automatically creates a capture filter that matches aspects of the
connection.
The following environment variables are analyzed:
SSH_CONNECTION (ssh)
<remote IP> <remote port> <local IP> <local port>
SSH_CLIENT (ssh)
<remote IP> <remote port> <local port>
REMOTEHOST (tcsh, others?)
<remote name>
DISPLAY (x11)
[remote name]:<display num>
SESSIONNAME (terminal server)
<remote name>

70

On Windows it asks the operating system if it’s running in a Remote Desktop Services environment.

While a Capture is running …
You might see the following dialog box while a capture is running:

check the screen below


Figure 35. The “Capture Information” dialog box

This dialog box shows a list of protocols and their activity over time. It can be enabled via the
“capture.show_info” setting in the “Advanced” preferences.

Stop the running capture
A running capture session will be stopped in one of the following ways:
1. The [ Stop Capture ] button in the “Capture Information” dialog box.
2. The Capture › Stop menu item.
3. The [ Stop ] toolbar button.
4. Pressing Ctrl + E .
5. The capture will be automatically stopped if one of the Stop Conditions is met, e.g., the
maximum amount of data was captured.

Restart a running capture
A running capture session can be restarted with the same capture options as the last time, this will
remove all packets previously captured. This can be useful, if some uninteresting packets are
captured and there’s no need to keep them.
Restart is a convenience function and equivalent to a capture stop following by an immediate
capture start. A restart can be triggered in one of the following ways:
1. Using the Capture › Restart menu item.
2. Using the [ Restart ] toolbar button.

71

File Input, Output, And Printing
Introduction
This chapter will describe input and output of capture data.
• Open capture files in various capture file formats
• Save and export capture files in various formats
• Merge capture files together
• Import text files containing hex dumps of packets
• Print packets

Open Capture Files
Wireshark can read in previously saved capture files. To read them, simply select the File › Open
menu or toolbar item. Wireshark will then pop up the “File Open” dialog box, which is discussed in
more detail in The “Open Capture File” Dialog Box.
You can use drag and drop to open files

TIP

On most systems you can open a file by simply dragging it in your file manager and
dropping it onto Wireshark’s main window.

If you haven’t previously saved the current capture file you will be asked to do so to prevent data
loss. This warning can be disabled in the preferences.
In addition to its native file format (pcapng), Wireshark can read and write capture files from a
large number of other packet capture programs as well. See Input File Formats for the list of
capture formats Wireshark understands.

The “Open Capture File” Dialog Box
The “Open Capture File” dialog box allows you to search for a capture file containing previously
captured packets for display in Wireshark. The following sections show some examples of the
Wireshark “Open File” dialog box. The appearance of this dialog depends on the system. However,
the functionality should be the same across systems.
Common dialog behavior on all systems:
• Select files and directories.
• Click the [ Open ] button to accept your selected file and open it.
• Click the [ Cancel ] button to go back to Wireshark and not load a capture file.

72

• The [ Help ] button will take you to this section of the “User’s Guide”.
Wireshark adds the following controls:
• View file preview information such as the size and the number of packets in a selected a
capture file.
• Specify a read filter with the “Read filter” field. This filter will be used when opening the new
file. The text field background will turn green for a valid filter string and red for an invalid one.
Read filters can be used to exclude various types of traffic, which can be useful for large capture
files. They use the same syntax as display filters, which are discussed in detail in Filtering
Packets While Viewing.
• Optionally force Wireshark to read a file as a particular type using the “Automatically detect file
type” drop-down.

check the screen below


Figure 36. “Open” on Microsoft Windows

This is the common Windows file open dialog along with some Wireshark extensions.

check the screen below

Figure 37. “Open” - Linux and UNIX

This is the common Qt file open dialog along with some Wireshark extensions.

Input File Formats
The native capture file formats used by Wireshark are:
• pcap. The default format used by the libpcap packet capture library. Used by tcpdump, _Snort,
Nmap, Ntop, and many other tools.
• pcapng. A flexible, extensible successor to the pcap format. Wireshark 1.8 and later save files as
pcapng by default. Versions prior to 1.8 used pcap. Used by Wireshark and by tcpdump in newer
versions of macOS.
The following file formats from other capture tools can be opened by Wireshark:
• Oracle (previously Sun) snoop and atmsnoop captures
• Finisar (previously Shomiti) Surveyor captures
• Microsoft Network Monitor captures
• Novell LANalyzer captures
• AIX iptrace captures
• Cinco Networks NetXray captures
• NETSCOUT (previously Network Associates/Network General) Windows-based Sniffer and
Sniffer Pro captures
• Network

General/Network

Associates

DOS-based

Sniffer

captures

(compressed

uncompressed) captures
• LiveAction (previously WildPackets/Savvius) *Peek/EtherHelp/PacketGrabber captures
• RADCOM’s WAN/LAN Analyzer captures

74

or

• Viavi (previously Network Instruments) Observer captures
• Lucent/Ascend router debug output
• captures from HP-UX nettl
• Toshiba’s ISDN routers dump output
• output from i4btrace from the ISDN4BSD project
• traces from the EyeSDN USB S0
• the IPLog format output from the Cisco Secure Intrusion Detection System
• pppd logs (pppdump format)
• the output from VMS’s TCPIPtrace/TCPtrace/UCX$TRACE utilities
• the text output from the DBS Etherwatch VMS utility
• Visual Networks’ Visual UpTime traffic capture
• the output from CoSine L2 debug
• the output from InfoVista (previously Accellent) 5Views LAN agents
• Endace Measurement Systems’ ERF format captures
• Linux Bluez Bluetooth stack hcidump -w traces
• Catapult (now Ixia/Keysight) DCT2000 .out files
• Gammu generated text output from Nokia DCT3 phones in Netmonitor mode
• IBM Series (OS/400) Comm traces (ASCII & UNICODE)
• Juniper Netscreen snoop captures
• Symbian OS btsnoop captures
• Tamosoft CommView captures
• Tektronix K12xx 32bit .rf5 format captures
• Tektronix K12 text file format captures
• Apple PacketLogger captures
• Captures from Aethra Telecommunications’ PC108 software for their test instruments
• Citrix NetScaler Trace files
• Android Logcat binary and text format logs
• Colasoft Capsa and PacketBuilder captures
• Micropross mplog files
• Unigraf DPA-400 DisplayPort AUX channel monitor traces
• 802.15.4 traces from Daintree’s Sensor Network Analyzer
• MPEG-2 Transport Streams as defined in ISO/IEC 13818-1

75

• Log files from the candump utility
• Logs from the BUSMASTER tool
• Ixia IxVeriWave raw captures
• Rabbit Labs CAM Inspector files
• systemd journal files
• 3GPP TS 32.423 trace files
New file formats are added from time to time.
It may not be possible to read some formats dependent on the packet types captured. Ethernet
captures are usually supported for most file formats but it may not be possible to read other packet
types such as PPP or IEEE 802.11 from all file formats.

Saving Captured Packets
You can save captured packets by using the File › Save or File › Save As… menu items. You can
choose which packets to save and which file format to be used.
Not all information will be saved in a capture file. For example, most file formats don’t record the
number of dropped packets. See Capture Files for details.

The “Save Capture File As” Dialog Box
The “Save Capture File As” dialog box allows you to save the current capture to a file. The exact
appearance of this dialog depends on your system. However, the functionality is the same across
systems. Examples are shown below.

check the screen below


Figure 38. “Save” on Microsoft Windows



This is the common Windows file save dialog with some additional Wireshark extensions.

check the screen below


Figure 39. “Save” on Linux and UNIX

This is the common Qt file save dialog with additional Wireshark extensions.
You can perform the following actions:
• Type in the name of the file in which you wish to save the captured packets.
• Select the directory to save the file into.
• Specify the format of the saved capture file by clicking on the “Save as” drop-down box. You can
choose from the types described in Output File Formats. Some capture formats may not be
available depending on the packet types captured.
• The [ Help ] button will take you to this section of the “User’s Guide”.
• “Compress with gzip” will compress the capture file as it is being written to disk.
• Click the [ Save ] button to accept your selected file and save it.
• Click on the [ Cancel ] button to go back to Wireshark without saving any packets.
If you don’t provide a file extension to the filename (e.g., .pcap) Wireshark will append the standard
file extension for that file format.
Wireshark can convert file formats

TIP

You can convert capture files from one format to another by opening a capture and
saving it as a different format.

If you wish to save some of the packets in your capture file you can do so via The “Export Specified
Packets” Dialog Box.

77

Output File Formats
Wireshark can save the packet data in its native file format (pcapng) and in the file formats of other
protocol analyzers so other tools can read the capture data.
Saving in a different format might lose data

NOTE

Saving your file in a different format might lose information such as comments,
name resolution, and time stamp resolution. See Time Stamps for more information
on time stamps.

The following file formats can be saved by Wireshark (with the known file extensions):
• pcapng (*.pcapng). A flexible, extensible successor to the libpcap format. Wireshark 1.8 and
later save files as pcapng by default. Versions prior to 1.8 used libpcap.
• pcap (*.pcap). The default format used by the libpcap packet capture library. Used by tcpdump,
_Snort, Nmap, Ntop, and many other tools.
• Accellent 5Views (*.5vw)
• captures from HP-UX nettl ({asterisktrc0,*.trc1)
• Microsoft Network Monitor - NetMon (*.cap)
• Network Associates Sniffer - DOS (*.cap,*.enc,*.trc,*.fdc,*.syc)
• Cinco Networks NetXray captures (*.cap)
• Network Associates Sniffer - Windows (*.cap)
• Network Instruments/Viavi Observer (*.bfr)
• Novell LANalyzer (*.tr1)
• Oracle (previously Sun) snoop (*.snoop,*.cap)
• Visual Networks Visual UpTime traffic (*.*)
• Symbian OS btsnoop captures (*.log)
• Tamosoft CommView captures (*.ncf)
• Catapult (now Ixia/Keysight) DCT2000 .out files (*.out)
• Endace Measurement Systems’ ERF format capture(*.erf)
• EyeSDN USB S0 traces (*.trc)
• Tektronix K12 text file format captures (*.txt)
• Tektronix K12xx 32bit .rf5 format captures (*.rf5)
• Android Logcat binary logs (*.logcat)
• Android Logcat text logs (*.*)
• Citrix NetScaler Trace files (*.cap)

78

New file formats are added from time to time.
Whether or not the above tools will be more helpful than Wireshark is a different question ;-)
Third party protocol analyzers may require specific file extensions

NOTE

Wireshark examines a file’s contents to determine its type. Some other protocol
analyzers only look at a file’s extension. For example, you might need to use the
.cap extension in order to open a file using the Windows version of Sniffer.

Merging Capture Files
Sometimes you need to merge several capture files into one. For example, this can be useful if you
have captured simultaneously from multiple interfaces at once (e.g., using multiple instances of
Wireshark).
There are three ways to merge capture files using Wireshark:
• Use the File › Merge menu to open the “Merge” dialog. See The “Merge With Capture File”
Dialog Box for details. This menu item will be disabled unless you have loaded a capture file.
• Use drag and drop to drop multiple files on the main window. Wireshark will try to merge the
packets in chronological order from the dropped files into a newly created temporary file. If you
drop a single file, it will simply replace the existing capture.
• Use the mergecap tool from the command line to merge capture files. This tool provides the most
options to merge capture files. See mergecap: Merging multiple capture files into one for details.

The “Merge With Capture File” Dialog Box
This lets you select a file to be merged into the currently loaded file. If your current data has not
been saved you will be asked to save it first.
Most controls of this dialog will work the same way as described in the “Open Capture File” dialog
box. See The “Open Capture File” Dialog Box for details.
Specific controls of this merge dialog are:
Prepend packets
Prepend the packets from the selected file before the currently loaded packets.
Merge chronologically
Merge both the packets from the selected and currently loaded file in chronological order.
Append packets
Append the packets from the selected file after the currently loaded packets.

check the screen below


Figure 40. “Merge” on Microsoft Windows

This is the common Windows file open dialog with additional Wireshark extensions.

check the screen below


Figure 41. “Merge” on Linux and UNIX

This is the Qt file open dialog with additional Wireshark extensions.

Import Hex Dump
Wireshark can read in a hex dump and write the data described into a temporary libpcap capture
file. It can read hex dumps with multiple packets in them, and build a capture file of multiple
packets. It is also capable of generating dummy Ethernet, IP and UDP, TCP, or SCTP headers, in order
to build fully processable packet dumps from hexdumps of application-level data only.
Alternatively, a Dummy PDU header can be added to specify a dissector the data should be passed

80

to initially.
Two methods for converting the input are supported:

Standard ASCII Hexdumps
Wireshark understands a hexdump of the form generated by od -Ax -tx1 -v. In other words, each
byte is individually displayed, with spaces separating the bytes from each other. Hex digits can be
upper or lowercase.
In normal operation, each line must begin with an offset describing the position in the packet,
followed a colon, space, or tab separating it from the bytes. There is no limit on the width or
number of bytes per line, but lines with only hex bytes without a leading offset are ignored (i.e., line
breaks should not be inserted in long lines that wrap.) Offsets are more than two digits; they are in
hex by default, but can also be in octal or decimal. Each packet must begin with offset zero, and an
offset zero indicates the beginning of a new packet. Offset values must be correct; an unexpected
value causes the current packet to be aborted and the next packet start awaited. There is also a
single packet mode with no offsets.
Packets may be preceded by a direction indicator ('I' or 'O') and/or a timestamp if indicated. If both
are present, the direction indicator precedes the timestamp. The format of the timestamps must be
specified. If no timestamp is parsed, in the case of the first packet the current system time is used,
while subsequent packets are written with timestamps one microsecond later than that of the
previous packet.
Other text in the input data is ignored. Any text before the offset is ignored, including email
forwarding characters '>'. Any text on a line after the bytes is ignored, e.g., an ASCII character dump
(but see -a to ensure that hex digits in the character dump are ignored). Any line where the first
non-whitespace character is a '#' will be ignored as a comment. Any lines of text between the
bytestring lines are considered preamble; the beginning of the preamble is scanned for the
direction indicator and timestamp as mentioned above and otherwise ignored.
Any line beginning with #TEXT2PCAP is a directive and options can be inserted after this command
to be processed by Wireshark. Currently there are no directives implemented; in the future, these
may be used to give more fine-grained control on the dump and the way it should be processed e.g.,
timestamps, encapsulation type etc.
In general, short of these restrictions, Wireshark is pretty liberal about reading in hexdumps and
has been tested with a variety of mangled outputs (including being forwarded through email
multiple times, with limited line wrap etc.)
Here is a sample dump that can be imported, including optional directional indicator and
timestamp:

81

I 2019-05-14T19:04:57Z
000000 00 e0 1e a7 05 6f 00 10 ........
000008 5a a0 b9 12 08 00 46 00 ........
000010 03 68 00 00 00 00 0a 2e ........
000018 ee 33 0f 19 08 7f 0f 19 ........
000020 03 80 94 04 00 00 10 01 ........
000028 16 a2 0a 00 03 50 00 0c ........
000030 01 01 0f 19 03 80 11 01 ........

Regular Text Dumps
Wireshark is also capable of scanning the input using a custom Perl regular expression as specified
by GLib’s GRegex here. Using a regex capturing a single packet in the given file Wireshark will
search the given file from start to the second to last character (the last character has to be \n and is
ignored) for non-overlapping (and non-empty) strings matching the given regex and then identify
the fields to import using named capturing subgroups. Using provided format information for each
field they are then decoded and translated into a standard libpcap file retaining packet order.
Note that each named capturing subgroup has to match exactly once a packet, but they may be
present multiple times in the regex.
For example, the following dump:

> 0:00:00.265620 a130368b000000080060
> 0:00:00.280836 a1216c8b00000000000089086b0b82020407
< 0:00:00.295459 a2010800000000000000000800000000
> 0:00:00.296982 a1303c8b00000008007088286b0bc1ffcbf0f9ff
> 0:00:00.305644 a121718b0000000000008ba86a0b8008
< 0:00:00.319061 a2010900000000000000001000600000
> 0:00:00.330937 a130428b00000008007589186b0bb9ffd9f0fdfa3eb4295e99f3aaffd2f005
> 0:00:00.356037 a121788b0000000000008a18
could be imported using these settings:

regex: ^(?<dir>[<>])\s(?<time>\d+:\d\d:\d\d.\d+)\s(?<data>[0-9a-fA-F]+)$
timestamp: %H:%M:%S.%f
dir: in: <
out: >
encoding: HEX
Caution has to be applied when discarding the anchors ^ and $, as the input is searched, not parsed,
meaning even most incorrect regexes will produce valid looking results when not anchored
(however, anchors are not guaranteed to prevent this). It is generally recommended to sanity check
any files created using this conversion.

82

Supported fields:
• data: Actual captured frame data
The only mandatory field. This should match the encoded binary data captured and is used as
the actual frame data to import.
• time: timestamp for the packet
The captured field will be parsed according to the given timestamp format into a timestamp.
If no timestamp is present an arbitrary counter will count up seconds and nanoseconds by one
each packet.
• dir: the direction the packet was sent over the wire
The captured field is expected to be one character in length, any remaining characters are
ignored (e.g., given "Input" only the 'I' is looked at). This character is compared to lists of
characters corresponding to inbound and outbound and the packet is assigned the
corresponding direction. If neither list yields a match, the direction is set to unknown.
If this field is not specified the entire file has no directional information.
• seqno: an ID for this packet
Each packet can be assigned an arbitrary ID that can used as field by Wireshark. This field is
assumed to be a positive integer base 10. This field can e.g. be used to reorder out of order
captures after the import.
If this field is not given, no IDs will be present in the resulting file.

The “Import From Hex Dump” Dialog Box
This dialog box lets you select a text file, containing a hex dump of packet data, to be imported and
set import parameters.

check the screen below


Figure 42. The “Import from Hex Dump” dialog in Hex Dump mode

Specific controls of this import dialog are split in three sections:
File Source
Determine which input file has to be imported
Input Format
Determine how the input file has to be interpreted.
Encapsulation
Determine how the data is to be encapsulated.

File source
Filename / Browse
Enter the name of the text file to import. You can use Browse to browse for a file.

Input Format
This section is split in the two alternatives for input conversion, accessible in the two Tabs "Hex
Dump" and "Regular Expression"
In addition to the conversion mode specific inputs, there are also common parameters, currently
only the timestamp format.

84

The Hex Dump tab
Offsets
Select the radix of the offsets given in the text file to import. This is usually hexadecimal, but
decimal and octal are also supported. Select None when only the bytes are present. These will be
imported as a single packet.
Direction indication
Tick this box if the text file to import has direction indicators before each frame. These are on a
separate line before each frame and start with either I or i for input and O or o for output.
The Regular Expression tab

check the screen below


Figure 43. The "Regular Expression" tab inside the "Import from Hex Dump” dialog.

Packet format regular expression
This is the regex used for searching packets and metadata inside the input file. Named capturing
subgroups are used to find the individual fields. Anchors ^ and $ are set to match directly before
and after newlines \n or \r\n. See GRegex for a full documentation.
Data encoding
The Encoding used for the binary data. Supported encodings are plain-hexadecimal, -octal,
-binary and base64. Plain here means no additional characters are present in the data field
beyond whitespaces, which are ignored. Any unexpected characters abort the import process.
Ignored whitespaces are \r, \n, \t, \v, ` ` and only for hex :, only for base64 =.
Any incomplete bytes at the field’s end are assumed to be padding to fill the last complete byte.
These bits should be zero, however, this is not checked.
Direction indication
The lists of characters indicating incoming vs. outgoing packets. These fields are only available
when the regex contains a (?<dir>…) group.
Common items

85

Timestamp Format
This is the format specifier used to parse the timestamps in the text file to import. It uses the
same format as strptime(3) with the addition of %f for zero padded fractions of seconds. The
precision of %f is determined from its length. The most common fields are %H, %M and %S for hours,
minutes and seconds. The straightforward HH:MM:SS format is covered by %T. For a full
definition of the syntax look for strptime(3),
In Regex mode this field is only available when a (?<time>…) group is present.
In Hex Dump mode if there are no timestamps in the text file to import, leave this field empty
and timestamps will be generated based on the time of import.

Encapsulation
Encapsulation type
Here you can select which type of frames you are importing. This all depends on from what type
of medium the dump to import was taken. It lists all types that Wireshark understands, so as to
pass the capture file contents to the right dissector.
Dummy header
When Ethernet encapsulation is selected you have to option to prepend dummy headers to the
frames to import. These headers can provide artificial Ethernet, IP, UDP, TCP or SCTP headers or
SCTP data chunks. When selecting a type of dummy header, the applicable entries are enabled,
others are greyed out and default values are used. When the Wireshark Upper PDU export
encapsulation is selected the option ExportPDU becomes available. This allows you to select the
name of the dissector these frames are to be directed to.
Maximum frame length
You may not be interested in the full frames from the text file, just the first part. Here you can
define how much data from the start of the frame you want to import. If you leave this open the
maximum is set to 256kiB.
Once all input and import parameters are setup click [ Import ] to start the import. If your current
data wasn’t saved before you will be asked to save it first.
If the import button doesn’t unlock, make sure all encapsulation parameters are in the expected
range and all unlocked fields are populated when using regex mode (the placeholder text is not
used as default).
When completed there will be a new capture file loaded with the frames imported from the text
file.

File Sets
When using the “Multiple Files” option while doing a capture (see: Capture files and file modes), the

86

capture data is spread over several capture files, called a file set.
As it can become tedious to work with a file set by hand, Wireshark provides some features to
handle these file sets in a convenient way.

How does Wireshark detect the files of a file set?
A filename in a file set uses the format Prefix_Number_DateTimeSuffix which might look
something like test_00001_20230714183910.pcap. All files of a file set share the same prefix
(e.g., “test”) and suffix (e.g., “.pcap”) and a varying middle part.
To find the files of a file set, Wireshark scans the directory where the currently loaded file
resides and checks for files matching the filename pattern (prefix and suffix) of the currently
loaded file.
This simple mechanism usually works well but has its drawbacks. If several file sets were
captured with the same prefix and suffix, Wireshark will detect them as a single file set. If
files were renamed or spread over several directories the mechanism will fail to find all files
of a set.
The following features in the File › File Set submenu are available to work with file sets in a
convenient way:
• The “List Files” dialog box will list the files Wireshark has recognized as being part of the
current file set.
• [ Next File ] closes the current and opens the next file in the file set.
• [ Previous File ] closes the current and opens the previous file in the file set.

The “List Files” Dialog Box

check the screen below


Figure 44. The “List Files” dialog box

Each line contains information about a file of the file set:
Filename
The name of the file. If you click on the filename (or the radio button left to it), the current file
will be closed and the corresponding capture file will be opened.
Created
The creation time of the file.
Last Modified
The last time the file was modified.
Size
The size of the file.
The last line will contain info about the currently used directory where all of the files in the file set
can be found.
The content of this dialog box is updated each time a capture file is opened/closed.
The [ Close ] button will, well, close the dialog box.

Exporting Data
Wireshark provides a variety of options for exporting packet data. This section describes general

88

ways to export data from the main Wireshark application. There are many other ways to export or
extract data from capture files, including processing tshark output and customizing Wireshark and
TShark using Lua scripts.

The “Export Specified Packets” Dialog Box
check the screen below


Figure 45. The “Export Specified Packets” dialog box

This is similar to the “Save” dialog box, but it lets you save specific packets. This can be useful for
trimming irrelevant or unwanted packets from a capture file. See Packet Range for details on the
range controls.

The “Export Packet Dissections” Dialog Box
This lets you save the packet list, packet details, and packet bytes as plain text, CSV, JSON, and other
formats.

check the screen below
Figure 46. The “Export Packet Dissections” dialog box

The format can be selected from the “Export As” drop-down and further customized using the
“Packet Range” and “Packet Format” controls. Some controls are unavailable for some formats,
notably CSV and JSON. The following formats are supported:
• Plain text as shown in the main window
• Comma-separated values (CSV)
• C-compatible byte arrays
• PSML (summary XML)
• PDML (detailed XML)
• JavaScript Object Notation (JSON)
Here are some examples of exported data:

90

Plain text

No.
SSID

Time
Source
Destination
Protocol Length
Info
1 0.000000
200.121.1.131
172.16.0.122
TCP
1454
10554 → 80 [ACK] Seq=1 Ack=1 Win=65535 Len=1400 [TCP segment of a reassembled PDU]
Frame 1: 1454 bytes on wire (11632 bits), 1454 bytes captured (11632 bits)
Ethernet II, Src: 00:50:56:c0:00:01, Dst: 00:0c:29:42:12:13
Internet Protocol Version 4, Src: 200.121.1.131 (200.121.1.131), Dst: 172.16.0.122
(172.16.0.122)
0100 .... = Version: 4
.... 0101 = Header Length: 20 bytes (5)
Differentiated Services Field: 0x00 (DSCP: CS0, ECN: Not-ECT)
Total Length: 1440
Identification: 0x0141 (321)
Flags: 0x0000
...0 0000 0000 0000 = Fragment offset: 0
Time to live: 106
Protocol: TCP (6)
Header checksum: 0xd390 [validation disabled]
[Header checksum status: Unverified]
Source: 200.121.1.131 (200.121.1.131)
Destination: 172.16.0.122 (172.16.0.122)
[Source GeoIP: PE, ASN 6147, Telefonica del Peru S.A.A.]
Transmission Control Protocol, Src Port: 10554, Dst Port: 80, Seq: 1, Ack: 1, Len:
1400

If you would like to be able to import any previously exported packets from a plain
text file it is recommended that you do the following:
• Add the “Absolute date and time” column.
• Temporarily hide all other columns.
TIP

• Disable the Edit › Preferences › Protocols › Data “Show not dissected data on new
Packet Bytes pane” preference. More details are provided in Preferences
• Include the packet summary line.
• Exclude column headings.
• Exclude packet details.
• Include the packet bytes.

91

CSV

"No.","Time","Source","Destination","Protocol","Length","SSID","Info","Win Size"
"1","0.000000","200.121.1.131","172.16.0.122","TCP","1454","","10554 > 80 [ACK]
Seq=1 Ack=1 Win=65535 Len=1400 [TCP segment of a reassembled PDU]","65535"
"2","0.000011","172.16.0.122","200.121.1.131","TCP","54","","[TCP ACKed unseen
segment] 80 > 10554 [ACK] Seq=1 Ack=11201 Win=53200 Len=0","53200"
"3","0.025738","200.121.1.131","172.16.0.122","TCP","1454","","[TCP Spurious
Retransmission] 10554 > 80 [ACK] Seq=1401 Ack=1 Win=65535 Len=1400 [TCP segment of a
reassembled PDU]","65535"
"4","0.025749","172.16.0.122","200.121.1.131","TCP","54","","[TCP Window Update] [TCP
ACKed unseen segment] 80 > 10554 [ACK] Seq=1 Ack=11201 Win=63000 Len=0","63000"
"5","0.076967","200.121.1.131","172.16.0.122","TCP","1454","","[TCP Previous segment
not captured] [TCP Spurious Retransmission] 10554 > 80 [ACK] Seq=4201 Ack=1
Win=65535 Len=1400 [TCP segment of a reassembled PDU]","65535"
JSON

{
"_index": "packets-2014-06-22",
"_type": "doc",
"_score": null,
"_source": {
"layers": {
"frame": {
"frame.encap_type": "1",
"frame.time": "Jun 22, 2014 13:29:41.834477000 PDT",
"frame.offset_shift": "0.000000000",
"frame.time_epoch": "1403468981.834477000",
"frame.time_delta": "0.450535000",
"frame.time_delta_displayed": "0.450535000",
"frame.time_relative": "0.450535000",
"frame.number": "2",
"frame.len": "86",
"frame.cap_len": "86",
"frame.marked": "0",
"frame.ignored": "0",
"frame.protocols": "eth:ethertype:ipv6:icmpv6",
"frame.coloring_rule.name": "ICMP",
"frame.coloring_rule.string": "icmp || icmpv6"
},
"eth": {
"eth.dst": "33:33:ff:9e:e3:8e",
"eth.dst_tree": {
"eth.dst_resolved": "33:33:ff:9e:e3:8e",
"eth.dst.oui": "3355647",
"eth.addr": "33:33:ff:9e:e3:8e",

92

"eth.addr_resolved": "33:33:ff:9e:e3:8e",
"eth.addr.oui": "3355647",
"eth.dst.lg": "1",
"eth.lg": "1",
"eth.dst.ig": "1",
"eth.ig": "1"
},
"eth.src": "00:01:5c:62:8c:46",
"eth.src_tree": {
"eth.src_resolved": "00:01:5c:62:8c:46",
"eth.src.oui": "348",
"eth.src.oui_resolved": "Cadant Inc.",
"eth.addr": "00:01:5c:62:8c:46",
"eth.addr_resolved": "00:01:5c:62:8c:46",
"eth.addr.oui": "348",
"eth.addr.oui_resolved": "Cadant Inc.",
"eth.src.lg": "0",
"eth.lg": "0",
"eth.src.ig": "0",
"eth.ig": "0"
},
"eth.type": "0x000086dd"
},
"ipv6": {
"ipv6.version": "6",
"ip.version": "6",
"ipv6.tclass": "0x00000000",
"ipv6.tclass_tree": {
"ipv6.tclass.dscp": "0",
"ipv6.tclass.ecn": "0"
},
"ipv6.flow": "0x00000000",
"ipv6.plen": "32",
"ipv6.nxt": "58",
"ipv6.hlim": "255",
"ipv6.src": "2001:558:4080:16::1",
"ipv6.addr": "2001:558:4080:16::1",
"ipv6.src_host": "2001:558:4080:16::1",
"ipv6.host": "2001:558:4080:16::1",
"ipv6.dst": "ff02::1:ff9e:e38e",
"ipv6.addr": "ff02::1:ff9e:e38e",
"ipv6.dst_host": "ff02::1:ff9e:e38e",
"ipv6.host": "ff02::1:ff9e:e38e",
"ipv6.geoip.src_summary": "US, ASN 7922, Comcast Cable Communications, LLC",
"ipv6.geoip.src_summary_tree": {
"ipv6.geoip.src_country": "United States",
"ipv6.geoip.country": "United States",
"ipv6.geoip.src_country_iso": "US",

93

"ipv6.geoip.country_iso": "US",
"ipv6.geoip.src_asnum": "7922",
"ipv6.geoip.asnum": "7922",
"ipv6.geoip.src_org": "Comcast Cable Communications, LLC",
"ipv6.geoip.org": "Comcast Cable Communications, LLC",
"ipv6.geoip.src_lat": "37.751",
"ipv6.geoip.lat": "37.751",
"ipv6.geoip.src_lon": "-97.822",
"ipv6.geoip.lon": "-97.822"
}
},
"icmpv6": {
"icmpv6.type": "135",
"icmpv6.code": "0",
"icmpv6.checksum": "0x00005b84",
"icmpv6.checksum.status": "1",
"icmpv6.reserved": "00:00:00:00",
"icmpv6.nd.ns.target_address": "2001:558:4080:16:be36:e4ff:fe9e:e38e",
"icmpv6.opt": {
"icmpv6.opt.type": "1",
"icmpv6.opt.length": "1",
"icmpv6.opt.linkaddr": "00:01:5c:62:8c:46",
"icmpv6.opt.src_linkaddr": "00:01:5c:62:8c:46"
}
}
}
}
}
]

The “Export Selected Packet Bytes” Dialog Box
Export the bytes selected in the “Packet Bytes” pane into a raw binary file.

check the screen below

Figure 47. The “Export Selected Packet Bytes” dialog box

File name
The file name to export the packet data to.
Save as type
The file extension.

The “Export PDUs to File…” Dialog Box
The “Export PDUs to File…” dialog box allows you to filter the captured Protocol Data Units (PDUs)
and export them into the file. It allows you to export reassembled PDUs avoiding lower layers such
as HTTP without TCP, and decrypted PDUs without the lower protocols such as HTTP without TLS
and TCP.
1. In the main menu select File › Export PDUs to File…. Wireshark will open a corresponding
dialog Export PDUs to File window.

check the screen below
Figure 48. Export PDUs to File window

2. To select the data according to your needs, optionally type a filter value into the Display Filter
field. For more information about filter syntax, see the Wireshark Filters man page.
3. In the field below the Display Filter field you can choose the level from which you want to
export the PDUs to the file. There are seven levels:
a. DLT User. You can export a protocol, which is framed in the user data link type table without
the need to reconfigure the DLT user table. For more information, see the How to Dissect
Anything page.
b. DVB-CI. You can use it for the Digital Video Broadcasting (DVB) protocol.
c. Logcat and Logcat Text. You can use them for the Android logs.
d. OSI layer 3. You can use it to export PDUs encapsulated in the IPSec or SCTP protocols.
e. OSI layer 4. You can use it to export PDUs encapsulated in the TCP or UDP protocols.
f. OSI layer 7. You can use it to export the following protocols: CredSSP over TLS, Diameter,
protocols encapsulated in TLS and DTLS, H.248, Megaco, RELOAD framing, SIP, SMPP.
NOTE

As a developer you can add any dissector to the existing list or define a new
entry in the list by using the functions in epan/exported_pdu.h.

4. To finish exporting PDUs to file, click the [ OK ] button in the bottom-right corner. This will close
the originally captured file and open the exported results instead as a temporary file in the
main Wireshark window.
5. You may save the temporary file just like any captured file. See Saving Captured Packets for
details.
The file produced has a Wireshark Upper PDU encapsulation type that has
NOTE

somewhat limited support outside of Wireshark, but is very flexible and can
contain PDUs for any protocol for which there is a Wireshark dissector.

96

The “Strip Headers…” Dialog Box
The “Strip Headers…” dialog box allows you to filter known encapsulation types on whatever
protocol layer they appear and export them into a new capture file, removing lower-level protocols.
It allows you to export reassembled packets and frames without lower layers such as GPF, GRE,
GSE, GTP-U, MPLS, MPE, PPP, and more. If Wireshark has performed decryption, then you can
export decrypted IP from protocols like IEEE 802.11 or IPSec without having to save encryption
keys.
The procedure is similar to that of The “Export PDUs to File…” Dialog Box:
1. In the main menu select File › Strip Headers…. Wireshark will open a corresponding dialog.
2. To select the data according to your needs, optionally type a filter value into the Display Filter
field. For more information about filter syntax, see the Wireshark Filters man page.
3. In the field below the Display Filter field you can choose the encapsulation type you want to
find and export to the file. There are two encapsulations supported:
a. Ethernet. You can use it to export Ethernet encapsulated in other protocols.
b. IP. You can use it to export IPv4 and IPv6 encapsulated in other protocols.
NOTE

As a developer you can add encapsulations to the list by using the functions
in epan/exported_pdu.h.

4. To finish exporting to file, click the [ OK ] button in the bottom-right corner. This will close the
originally captured file and open the exported results instead as a temporary file in the main
Wireshark window.
5. You may save the temporary file just like any captured file. See Saving Captured Packets for
details.
NOTE

The new capture files produced have standard encapsulation types and can be
read in nearly any tool.

The “Export TLS Session Keys…” Dialog Box
Transport Layer Security (TLS) encrypts the communication between a client and a server. The
most common use for it is web browsing via HTTPS.
Decryption of TLS traffic requires TLS secrets. You can get them in the form of stored session keys
in a "key log file", or by using an RSA private key file. For more details, see the TLS wiki page.
The File › Export TLS Session Keys… menu option generates a new "key log file" which contains
TLS session secrets known by Wireshark. This feature is useful if you typically decrypt TLS sessions
using the RSA private key file. The RSA private key is very sensitive because it can be used to
decrypt other TLS sessions and impersonate the server. Session keys can be used only to decrypt

97

sessions from the packet capture file. However, session keys are the preferred mechanism for
sharing data over the Internet.
To export captured TLS session keys, follow the steps below:
1. In the main menu select File › Export TLS Session Keys…. Wireshark will open a
corresponding dialog Export TLS Session Keys window.

check the screen below


Figure 49. Export TLS Session Keys window

2. Type the desired file name in the Save As field.
3. Choose the destination folder for your file in the Where field.
4. Press the [ Save ] button to complete the export file procedure.

The “Export Objects” Dialog Box
This feature scans through the selected protocol’s streams in the currently open capture file or
running capture and allows the user to export reassembled objects to the disk. For example, if you
select HTTP, you can export HTML documents, images, executables, and any other files transferred
over HTTP to the disk. If you have a capture running, this list is automatically updated every few
seconds with any new objects seen. The saved objects can then be opened or examined
independently of Wireshark.

check the screen below

Figure 50. The “Export Objects” dialog box

Columns:
Packet
The packet number in which this object was found. In some cases, there can be multiple objects
in the same packet.
Hostname
The hostname of the server that sent this object.
Content Type
The content type of this object.
Size
The size of this object in bytes.
Filename: The filename for this object. Each protocol generates the filename differently. For
example, HTTP uses the final part of the URI and IMF uses the subject of the email.
Inputs:
Text Filter
Only displays objects containing the specified text string.

99

Help
Opens this section of the “User’s Guide”.
Save All
Saves all objects (including those not displayed) using the filename from the filename column.
You will be asked what directory or folder to save them in.
Close
Closes the dialog without exporting.
Save
Saves the currently selected object as a filename you specify. The default filename to save as is
taken from the filename column of the objects list.

Printing Packets
To print packets, select the File › Print… menu item. Wireshark will display the “Print” dialog box
as shown below.
It’s easy to waste paper doing this

WARNING

Printed output can contain lots of text, particularly if you print packet details
and bytes.

The “Print” Dialog Box

check the screen below
Figure 51. The “Print” dialog box

The “Print” dialog box shows a preview area which shows the result of changing the packet format
settings. You can zoom in and out using the + and - keys and reset the zoom level using the 0 key.
The following settings are available in the Print dialog box:
Packet Format
Lets you specify what gets printed. See The “Packet Format” frame for details.
Summary line
Include a summary line for each packet. The line will contain the same fields as the packet
list.
Details
Print details for each packet.
Bytes
Print a hex dump of each packet.
Packet Range
Select the packets to be printed. See The “Packet Range” Frame for details.
[ Page Setup… ] lets you select the page size and orientation.

101

[ Print… ] prints to your default printer.
[ Cancel ] will close the dialog without printing.
[ Help ] will display this section of the “User’s Guide”.

The “Packet Range” Frame
The packet range frame is a part of the “Export Specified Packets,” “Export Packet Dissections,” and
“Print” dialog boxes. You can use it to specify which packets will be exported or printed.

check the screen below


Figure 52. The “Packet Range” frame

By default, the [ Displayed ] button is set, which only exports or prints the packets that match the
current display filter. Selecting [ Captured ] will export or print all packets. You can further limit
what you export or print to the following:
All packets
All captured or displayed packets depending on the primary selection above.
Selected packet
Only the selected packet.
Marked packets
Only marked packets. See Marking Packets.
First to last marked
Lets you mark an inclusive range of packets.
Range
Lets you manually specify a range of packets, e.g., 5,10-15,20- will process the packet number
five, the packets from packet number ten to fifteen (inclusive) and every packet from number
twenty to the end of the capture.
Remove ignored packets
Don’t export or print ignored packets. See Ignoring Packets.

102

The Packet Format Frame
The packet format frame is also a part of the “Export Packet Dissections” and “Print” dialog boxes.
You can use it to specify which parts of dissection are exported or printed.

check the screen below
Figure 53. The “Packet Format” frame

Each of the settings below correspond to the packet list, packet detail, and packet bytes in the main
window.
Packet summary line
Export or print each summary line as shown in the “Packet List” pane.
Packet details
Export or print the contents of the “Packet Details” tree.
All collapsed
Export or print as if the “Packet Details” tree is in the “all collapsed” state.
As displayed
Export or print as if the “Packet Details” tree is in the “as displayed” state.
All expanded
Export or print as if the “Packet Details” tree is in the “all expanded” state.
Packet Bytes
Export or print the contents of the “Packet Bytes” pane.
Each packet on a new page
For printing and some export formats, put each packet on a separate page. For example, when
exporting to a text file this will put a form feed character between each packet.

103

Capture information header
Add a header to each page with capture filename and the number of total packets and shown
packets.

104

Working With Captured Packets
Viewing Packets You Have Captured
Once you have captured some packets or you have opened a previously saved capture file, you can
view the packets that are displayed in the packet list pane by simply clicking on a packet in the
packet list pane, which will bring up the selected packet in the tree view and byte view panes.
You can then expand any part of the tree to view detailed information about each protocol in each
packet. Clicking on an item in the tree will highlight the corresponding bytes in the byte view. An
example with a TCP packet selected is shown in Wireshark with a TCP packet selected for viewing.
It also has the Acknowledgment number in the TCP header selected, which shows up in the byte
view as the selected bytes.

check the screen below

Figure 54. Wireshark with a TCP packet selected for viewing

You can also select and view packets the same way while Wireshark is capturing if you selected
“Update list of packets in real time” in the “Capture Preferences” dialog box.
In addition you can view individual packets in a separate window as shown in Viewing a packet in
a separate window. You can do this by double-clicking on an item in the packet list or by selecting
the packet in which you are interested in the packet list pane and selecting View › Show Packet in
New Window. This allows you to easily compare two or more packets, even across multiple files.

check the screen below
Figure 55. Viewing a packet in a separate window

Along with double-clicking the packet list and using the main menu there are a number of other
ways to open a new packet window:
• Hold down the shift key and double-click on a frame link in the packet details.
• From The menu items of the “Packet List” pop-up menu.
• From The menu items of the “Packet Details” pop-up menu.

Pop-up Menus
You can open a pop-up menu over the “Packet List”, its column heading, “Packet Details”, or “Packet
Bytes” by clicking your right mouse button on the corresponding item.

Pop-up Menu Of The “Packet List” Column Header

check the screen below
Figure 56. Pop-up menu of the “Packet List” column header

The following table gives an overview of which functions are available in this header, where to find
the corresponding function in the main menu, and a description of each item.
Table 18. The menu items of the “Packet List” column header pop-up menu

Item

Description

Align Left

Left-align values in this column.

Align Center

Center-align values in this column.

Align Right

Right-align values in this column.

Column Preferences…

Open the “Preferences” dialog for this column.

Edit Column

Open the column editor toolbar for this column.

Resize To Contents

Resize the column to fit its values.

Resolve Names

If this column contains addresses, resolve them.

No., Time, Source, et al.

Show or hide a column by selecting its item.

Remove Column

Remove this column, similar to deleting it in the “Preferences”
dialog.

Pop-up Menu Of The “Packet List” Pane

check the screen below
Figure 57. Pop-up menu of the “Packet List” pane

The following table gives an overview of which functions are available in this pane, where to find
the corresponding function in the main menu, and a short description of each item.
Table 19. The menu items of the “Packet List” pop-up menu

Item

Corresp Description
onding
main
menu
item

Mark Packet (toggle)

Edit

Mark or unmark a packet.

Ignore Packet (toggle)

Edit

Ignore or inspect this packet while dissecting the capture
file.

Set Time Reference

Edit

Set or reset a time reference.

Edit

Opens the “Time Shift” dialog, which allows you to adjust

(toggle)
Time Shift

the timestamps of some or all packets.
Packet Comment…

Edit

Opens the “Packet Comment” dialog, which lets you add a
comment to a single packet. Note that the ability to save
packet comments depends on your file format. E.g.,
pcapng supports comments, pcap does not.

108

Item

Corresp Description
onding
main
menu
item

Edit Resolved Name

Allows you to enter a name to resolve for the selected
address.

Apply as Filter

Analyze Immediately replace or append the current display filter
based on the most recent packet list or packet details item
selected. The first submenu item shows the filter and
subsequent items show the different ways that the filter
can be applied.

Prepare as Filter

Analyze Change the current display filter based on the most recent
packet list or packet details item selected, but don’t apply
it. The first submenu item shows the filter and subsequent
items show the different ways that the filter can be
changed.

Conversation Filter

Apply a display filter with the address information from
the selected packet. For example, the IP menu entry will
set a filter to show the traffic between the two IP
addresses of the current packet.

Colorize Conversation

Create a new colorizing rule based on address information
from the selected packet.

SCTP

Allows you to analyze and prepare a filter for this SCTP
association.

Follow › TCP Stream

Analyze Open a window that displays all the TCP segments
captured that are on the same TCP connection as a
selected packet. See Following Protocol Streams.

Follow › UDP Stream

Analyze Same functionality as “Follow TCP Stream” but for UDP

Follow › DCCP Stream

Analyze Same functionality as “Follow TCP Stream” but for DCCP

Follow › TLS Stream

Analyze Same functionality as “Follow TCP Stream” but for TLS or

“streams”.
streams.
SSL streams. See the wiki page on SSL for instructions on
providing TLS keys.

Follow › HTTP Stream
Copy › Summary as Text

Analyze Same functionality as “Follow TCP Stream” but for HTTP
streams.
Copy the summary fields as displayed to the clipboard as
tab-separated text.

109

Item

Corresp Description
onding
main
menu
item

Copy › …as CSV

Copy the summary fields as displayed to the clipboard as

Copy › …as YAML

Copy the summary fields as displayed to the clipboard as

Copy › As Filter

Prepare a display filter based on the currently selected

Copy › Bytes as Hex + ASCII

Copy the packet bytes to the clipboard in full “hexdump”

comma-separated text.
YAML data.
item and copy that filter to the clipboard.

Dump

format.

Copy › …as Hex Dump

Copy the packet bytes to the clipboard in “hexdump”

Copy › …as Printable Text

Copy the packet bytes to the clipboard as ASCII text,

Copy › …as a Hex Stream

Copy the packet bytes to the clipboard as an unpunctuated

Copy › …as Raw Binary

Copy the packet bytes to the clipboard as raw binary. The

format without the ASCII portion.
excluding non-printable characters.
list of hex digits.
data is stored in the clipboard using the MIME type
“application/octet-stream”.

Protocol Preferences

Adjust the preferences for the selected protocol.

Decode As…

Analyze Change or apply a new relation between two dissectors.

Show Packet in New

View

Window

Shows the selected packet in a separate window. The
separate window shows only the packet details and bytes.
See Viewing a packet in a separate window for details.

Pop-up Menu Of The “Packet Details” Pane

check the screen below
Figure 58. Pop-up menu of the “Packet Details” pane

The following table gives an overview of which functions are available in this pane, where to find
the corresponding function in the main menu, and a short description of each item.
Table 20. The menu items of the “Packet Details” pop-up menu

Item

Corresp Description
onding
main
menu
item

Expand Subtrees

View

Expand the currently selected subtree.

Collapse Subtrees

View

Collapse the currently selected subtree.

Expand All

View

Expand all subtrees in all packets in the capture.

Collapse All

View

Wireshark keeps a list of all the protocol subtrees that are
expanded, and uses it to ensure that the correct subtrees
are expanded when you display a packet. This menu item
collapses the tree view of all packets in the capture list.

Apply as Column

Use the selected protocol item to create a new column in
the packet list.

111

Item

Corresp Description
onding
main
menu
item

Apply as Filter

Analyze Immediately replace or append the current display filter
based on the most recent packet list or packet details item
selected. The first submenu item shows the filter and
subsequent items show the different ways that the filter
can be applied.

Prepare as Filter

Analyze Change the current display filter based on the most recent
packet list or packet details item selected, but don’t apply
it. The first submenu item shows the filter and subsequent
items show the different ways that the filter can be
changed.

Colorize with Filter

This menu item uses a display filter with the information
from the selected protocol item to build a new colorizing
rule.

Follow › TCP Stream

Analyze Open a window that displays all the TCP segments
captured that are on the same TCP connection as a
selected packet. See Following Protocol Streams.

Follow › UDP Stream

Analyze Same functionality as “Follow TCP Stream” but for UDP

Follow › TLS Stream

Analyze Same functionality as “Follow TCP Stream” but for TLS or

“streams”.
SSL streams. See the wiki page on SSL for instructions on
providing TLS keys.

Follow › HTTP Stream

Analyze Same functionality as “Follow TCP Stream” but for HTTP

Copy › All Visible Items

Edit

Copy the packet details as displayed.

Copy › All Visible Selected

Edit

Copy the selected packet detail and its children as

streams.

displayed.

Tree Items
Copy › Description

Edit

Copy › Fieldname

Edit

Copy › Value

Edit

Copy › As Filter

Edit

112

Copy the displayed text of the selected field to the system
clipboard.
Copy the name of the selected field to the system
clipboard.
Copy the value of the selected field to the system
clipboard.
Prepare a display filter based on the currently selected
item and copy it to the clipboard.

Item

Corresp Description
onding
main
menu
item

Copy › Bytes as Hex + ASCII

Copy the packet bytes to the clipboard in full “hexdump”

Dump

format.

Copy › …as Hex Dump

Copy the packet bytes to the clipboard in “hexdump”

Copy › …as Printable Text

Copy the packet bytes to the clipboard as ASCII text,

Copy › …as a Hex Stream

Copy the packet bytes to the clipboard as an unpunctuated

Copy › …as Raw Binary

Copy the packet bytes to the clipboard as raw binary. The

format without the ASCII portion.
excluding non-printable characters.
list of hex digits.
data is stored in the clipboard using the MIME type
“application/octet-stream”.
Copy the packet bytes to the clipboard as C-style escape

Copy › …as Escaped String
Export Packet Bytes…

sequences.
File

This menu item is the same as the File menu item of the
same name. It allows you to export raw packet bytes to a
binary file.

Wiki Protocol Page

Open the wiki page for the selected protocol in your web
browser.

Filter Field Reference

Open the filter field reference web page for the selected
protocol in your web browser.

Protocol Preferences

Adjust the preferences for the selected protocol.

Decode As…

Analyze Change or apply a new relation between two dissectors.

Go to Linked Packet

Go

If the selected field has a corresponding packet such as the
matching request for a DNS response, go to it.

Show Linked Packet in
New Window

Go

If the selected field has a corresponding packet such as the
matching request for a DNS response, show the selected
packet in a separate window. See Viewing a packet in a
separate window for details.

Pop-up Menu Of The “Packet Bytes” Pane

check the screen below
Figure 59. Pop-up menu of the “Packet Bytes” pane

The following table gives an overview of which functions are available in this pane along with a
short description of each item.
Table 21. The menu items of the “Packet Bytes” pop-up menu

Item

Description

Copy Bytes as Hex + ASCII

Copy the packet bytes to the clipboard in full “hexdump” format.

Dump
…as Hex Dump

Copy the packet bytes to the clipboard in “hexdump” format without
the ASCII portion.

…as Printable Text

Copy the packet bytes to the clipboard as ASCII text, excluding nonprintable characters.

…as a Hex Stream

Copy the packet bytes to the clipboard as an unpunctuated list of hex
digits.

…as Raw Binary

Copy the packet bytes to the clipboard as raw binary. The data is
stored in the clipboard using the MIME type “application/octetstream”.

…as Escaped String

Copy the packet bytes to the clipboard as C-style escape sequences.

Show bytes as hexadecimal Display the byte data as hexadecimal digits.
Show bytes as bits

114

Display the byte data as binary digits.

Item

Description

Show text based on packet Show the “hexdump” data with text.
…as ASCII

Use ASCII encoding when displaying “hexdump” text.

…as EBCDIC

Use EBCDIC encoding when displaying “hexdump” text.

Pop-up Menu Of The “Packet Diagram” Pane
check the screen below


Figure 60. Pop-up menu of the “Packet Diagram” pane

The following table gives an overview of which functions are available in this pane along with a
short description of each item.
Table 22. The menu items of the “Packet Diagram” pop-up menu

Item

Description

Show Field Values

Display current value for each field on the packet diagram.

Save Diagram As…

Save the packet diagram to an image file (PNG, BMP, JPEG).

Copy as Raster Image

Copy the packet diagram to the clipboard in raster (ARGB32) format.

Filtering Packets While Viewing
Wireshark has two filtering languages: capture filters and display filters. Capture filters are used for
filtering when capturing packets and are discussed in Filtering while capturing. Display filters are
used for filtering which packets are displayed and are discussed below. For more information about
display filter syntax, see the wireshark-filter(4) man page.
Display filters allow you to concentrate on the packets you are interested in while hiding the
currently uninteresting ones. They allow you to only display packets based on:
• Protocol
• The presence of a field
• The values of fields

115

• A comparison between fields
• … and a lot more!
To only display packets containing a particular protocol, type the protocol name in the display filter
toolbar of the Wireshark window and press enter to apply the filter. Filtering on the TCP protocol
shows an example of what happens when you type tcp in the display filter toolbar.
NOTE

NOTE

Protocol and field names are usually in lowercase.
Don’t forget to press enter or click on the apply display filter button after entering
the filter expression.

check the screen below

Figure 61. Filtering on the TCP protocol

As you may have noticed, only packets containing the TCP protocol are now displayed, so packets 110 are hidden and packet number 11 is the first packet displayed.
NOTE

When using a display filter, all packets remain in the capture file. The display filter
only changes the display of the capture file but not its content!

To remove the filter, click on the [ Clear ] button to the right of the display filter field. All packets
will become visible again.

116

Display filters can be very powerful and are discussed in further detail in Building Display Filter
Expressions
It’s also possible to create display filters with the Display Filter Expression dialog box. More
information about the Display Filter Expression dialog box is available in The “Display Filter
Expression” Dialog Box.

Building Display Filter Expressions
Wireshark provides a display filter language that enables you to precisely control which packets
are displayed. They can be used to check for the presence of a protocol or field, the value of a field,
or even compare two fields to each other. These comparisons can be combined with logical
operators, like "and" and "or", and parentheses into complex expressions.
The following sections will go into the display filter functionality in more detail.
TIP

There are many display filter examples on the Wireshark Wiki Display Filter page at:
https://gitlab.com/wireshark/wireshark/-/wikis/DisplayFilters.

Display Filter Fields
The simplest display filter is one that displays a single protocol. To only display packets containing a
particular protocol, type the protocol into Wireshark’s display filter toolbar. For example, to only
display TCP packets, type tcp into Wireshark’s display filter toolbar. Similarly, to only display
packets containing a particular field, type the field into Wireshark’s display filter toolbar. For
example, to only display HTTP requests, type http.request into Wireshark’s display filter toolbar.
You can filter on any protocol that Wireshark supports. You can also filter on any field that a
dissector adds to the tree view, if the dissector has added an abbreviation for that field. A full list of
the available protocols and fields is available through the menu item View › Internals › Supported
Protocols.

Comparing Values
You can build display filters that compare values using a number of different comparison
operators. For example, to only display packets to or from the IP address 192.168.0.1, use
ip.addr==192.168.0.1.
A complete list of available comparison operators is shown in Display Filter comparison operators.
TIP

English and C-like operators are interchangeable and can be mixed within a filter
string.

Table 23. Display Filter comparison operators

117

English

Alias

C-like

Description

Example

eq

any_eq

==

Equal (any if more than one)

ip.src == 10.0.0.5

ne

all_ne

!=

Not equal (all if more than one) ip.src != 10.0.0.5

all_eq

===

Equal (all if more than one)

ip.src === 10.0.0.5

any_ne

!==

Not equal (any if more than

ip.src !== 10.0.0.5

one)
gt

>

Greater than

frame.len > 10

lt

<

Less than

frame.len < 128

ge

>=

Greater than or equal to

frame.len ge 0x100

le

<=

Less than or equal to

frame.len <= 0x20

Protocol, field or slice contains

sip.To contains "a1762"

contains

a value
matches

~

Protocol or text field matches a
Perl-compatible regular

http.host matches
"acme\\.(org|com|net)"

expression

NOTE

The meaning of != (all not equal) was changed in Wireshark 3.6. Before it used to
mean "any not equal".

All protocol fields have a type. Display Filter Field Types provides a list of the types with examples
of how to use them in display filters.
Display Filter Field Types
Unsigned integer
Can be 8, 16, 24, 32, or 64 bits. You can express integers in decimal, octal, hexadecimal or binary.
The following display filters are equivalent:
ip.len le 1500
ip.len le 02734
ip.len le 0x5dc
ip.len le 0b10111011100
Signed integer
Can be 8, 16, 24, 32, or 64 bits. As with unsigned integers you can use decimal, octal, hexadecimal
or binary.
Boolean
Can be 1 or "True" or "TRUE", 0 or "False" or "FALSE" (without quotes).

118

A Boolean field is present regardless if its value is true or false. For example, tcp.flags.syn is
present in all TCP packets containing the flag, whether the SYN flag is 0 or 1. To only match TCP
packets with the SYN flag set, you need to use tcp.flags.syn == 1 or tcp.flags.syn == True.
Ethernet address
6 bytes separated by a colon (:), dot (.), or dash (-) with one or two bytes between separators:
eth.dst == ff:ff:ff:ff:ff:ff
eth.dst == ff-ff-ff-ff-ff-ff
eth.dst == ffff.ffff.ffff
IPv4 address
ip.addr == 192.168.0.1
Classless InterDomain Routing (CIDR) notation can be used to test if an IPv4 address is in a
certain subnet. For example, this display filter will find all packets in the 129.111 Class-B
network:
ip.addr == 129.111.0.0/16
IPv6 address
ipv6.addr == ::1
As with IPv4 addresses, IPv6 addresses can match a subnet.
Text string
http.request.uri == "https://www.wireshark.org/"
Strings are a sequence of bytes. Functions like lower() use ASCII, otherwise no particular
encoding is assumed. String literals are specified with double quotes. Characters can also be
specified using a byte escape sequence using hex \xhh or octal \ddd, where h and d are hex and
octal numerical digits respectively:
dns.qry.name contains "www.\x77\x69\x72\x65\x73\x68\x61\x72\x6b.org"
Alternatively, a raw string syntax can be used. Such strings are prefixed with r or R and treat
backslash as a literal character.
http.user_agent matches r"\(X11;"
Date and time
frame.time == "Sep 26, 2004 23:18:04.954975"
ntp.xmt ge "2020-07-04 12:34:56"
The value of an absolute time field is expressed as a string, using one of the two formats above.
Fractional seconds can be omitted or specified up to nanosecond precision; extra trailing zeros

119

are allowed but not other digits. The string cannot take a time zone suffix, and is always parsed
as in the local time zone, even for fields that are displayed in UTC.
In the first format, the abbreviated month names must be in English regardless of locale. In the
second format, any number of time fields may be omitted, in the order from least significant
(seconds) to most, but at least the entire date must be specified:
frame.time < "2022-01-01"
In the second format, a T may appear between the date and time as in ISO 8601, but not when
less significant times are dropped.
Some Examples

udp contains 81:60:03
The display filter above matches packets that contains the 3-byte sequence 0x81, 0x60, 0x03
anywhere in the UDP header or payload.

sip.To contains "a1762"
The display filter above matches packets where the SIP To-header contains the string "a1762"
anywhere in the header.

http.host matches "acme\\.(org|com|net)"
The display filter above matches HTTP packets where the HOST header contains acme.org,
acme.com, or acme.net. Comparisons are case-insensitive.

tcp.flags & 0x02
That display filter will match all packets that contain the “tcp.flags” field with the 0x02 bit, i.e., the
SYN bit, set.
Possible Pitfalls Using Regular Expressions
String literals containing regular expressions are parsed twice. Once by Wireshark’s display filter
engine and again by the PCRE2 library. It’s important to keep this in mind when using the "matches"
operator with regex escape sequences and special characters.
For example, the filter expression frame matches "AB\x43" uses the string "ABC" as input pattern to
PCRE. However, the expression frame matches "AB\\x43" uses the string "AB\x43" as the pattern. In
this case both expressions give the same result because Wireshark and PCRE both support the same

120

byte escape sequence (0x43 is the ASCII hex code for C).
An example where this fails badly is foo matches "bar\x28". Because 0x28 is the ASCII code for ( the
pattern input to PCRE is "bar(". This regular expression is syntactically invalid (missing closing
parenthesis). To match a literal parenthesis in a display filter regular expression it must be escaped
(twice) with backslashes.
TIP

Using raw strings avoids most problem with the "matches" operator and double
escape requirements.

Combining Expressions
You can combine filter expressions in Wireshark using the logical operators shown in Display Filter
Logical Operations
Table 24. Display Filter Logical Operations

English

C-like

Description Example

and

&&

Logical AND ip.src==10.0.0.5 and tcp.flags.fin

or

||

Logical OR

ip.src==10.0.0.5 or ip.src==192.1.1.1

xor

^^

Logical XOR

tr.dst[0:3] == 0.6.29 xor tr.src[0:3] == 0.6.29

not

!

Logical NOT

not llc

[…]

Subsequence See “Slice Operator” below.

in

Set

http.request.method in {"HEAD", "GET"}. See

Membership “Membership Operator” below.

Slice Operator
Wireshark allows you to select a subsequence of a sequence in rather elaborate ways. After a label
you can place a pair of brackets [] containing a comma separated list of range specifiers.

eth.src[0:3] == 00:00:83
The example above uses the n:m format to specify a single range. In this case n is the beginning
offset and m is the length of the range being specified.

eth.src[1-2] == 00:83
The example above uses the n-m format to specify a single range. In this case n is the beginning
offset and m is the ending offset.

121

eth.src[:4] == 00:00:83:00
The example above uses the :m format, which takes everything from the beginning of a sequence to
offset m. It is equivalent to 0:m

eth.src[4:] == 20:20
The example above uses the n: format, which takes everything from offset n to the end of the
sequence.

eth.src[2] == 83
The example above uses the n format to specify a single range. In this case the element in the
sequence at offset n is selected. This is equivalent to n:1.

eth.src[0:3,1-2,:4,4:,2] ==
00:00:83:00:83:00:00:83:00:20:20:83
Wireshark allows you to string together single ranges in a comma separated list to form compound
ranges as shown above.

The Layer Operator
A field can be restricted to a certain layer in the protocol stack using the layer operator (#), followed
by a decimal number:

ip.addr#2 == 192.168.30.40
matches only the inner (second) layer in the packet. Layers use simple stacking semantics and
protocol layers are counted sequentially starting from 1. For example, in a packet that contains two
IPv4 headers, the outer (first) source address can be matched with "ip.src#1" and the inner (second)
source address can be matched with "ip.src#2".
For more complicated ranges the same syntax used with slices is valid:

tcp.port#[2-4]
means layers number 2, 3 or 4 inclusive. The hash symbol is required to distinguish a layer range
from a slice.

122

Membership Operator
Wireshark allows you to test a field for membership in a set of values or fields. After the field name,
use the in operator followed by the set items surrounded by braces {}. For example, to display
packets with a TCP source or destination port of 80, 443, or 8080, you can use tcp.port in {80, 443,
8080}. Set elements must be separated by commas. The set of values can also contain ranges:
tcp.port in {443,4430..4434}.
The display filter

tcp.port in {80, 443, 8080}
is equivalent to

tcp.port == 80 || tcp.port == 443 || tcp.port == 8080
However, the display filter
NOTE

tcp.port in {443, 4430..4434}
is not equivalent to

tcp.port == 443 || (tcp.port >= 4430 && tcp.port <= 4434)
This is because comparison operators are satisfied when any field matches the
filter, so a packet with a source port of 56789 and destination port of port 80 would
also match the second filter since 56789 >= 4430 && 80 <= 4434 is true. In contrast,
the membership operator tests a single field against the range condition.
Sets are not just limited to numbers, other types can be used as well:

http.request.method in {"HEAD", "GET"}
ip.addr in {10.0.0.5 .. 10.0.0.9, 192.168.1.1..192.168.1.9}
frame.time_delta in {10 .. 10.5}

Arithmetic operators
You can perform the arithmetic operations on numeric fields shown in Display Filter Arithmetic
Operations
Table 25. Display Filter Arithmetic Operations

123

Name

Syntax

Description

Unary minus

-A

Negation of A

Addition

A+B

Add B to A

Subtraction

A-B

Subtract B from A

Multiplication

A*B

Multiply A times B

Division

A/B

Divide A by B

Modulo

A%B

Remainder of A divided by B

Bitwise AND

A&B

Bitwise AND of A and B

Arithmetic expressions can be grouped using curly braces.

Functions
The display filter language has a number of functions to convert fields, see Display Filter Functions.
Table 26. Display Filter Functions

Function

Description

upper

Converts a string field to uppercase.

lower

Converts a string field to lowercase.

len

Returns the byte length of a string or bytes field.

count

Returns the number of field occurrences in a frame.

string

Converts a non-string field to a string.

max

Return the maximum value for the arguments.

min

Return the minimum value for the arguments.

abs

Return the absolute value for the argument.

The upper and lower functions can used to force case-insensitive matches: lower(http.server)
contains "apache".
To find HTTP requests with long request URIs: len(http.request.uri) > 100. Note that the len
function yields the string length in bytes rather than (multi-byte) characters.
Usually an IP frame has only two addresses (source and destination), but in case of ICMP errors or
tunneling, a single packet might contain even more addresses. These packets can be found with
count(ip.addr) > 2.
The string function converts a field value to a string, suitable for use with operators like "matches"
or "contains". Integer fields are converted to their decimal representation. It can be used with
IP/Ethernet addresses (as well as others), but not with string or byte fields.

124

For example, to match odd frame numbers:

string(frame.number) matches "[13579]$"
To match IP addresses ending in 255 in a block of subnets (172.16 to 172.31):

string(ip.dst) matches r"^172\.(1[6-9]|2[0-9]|3[0-1])\.[0-9]{1,3}\.255"
The functions max() and min() take any number of arguments of the same type and returns the
largest/smallest respectively of the set.

max(tcp.srcport, tcp.dstport) <= 1024

Sometimes Fields Change Names
As protocols evolve they sometimes change names or are superseded by newer standards. For
example, DHCP extends and has largely replaced BOOTP and TLS has replaced SSL. If a protocol
dissector originally used the older names and fields for a protocol the Wireshark development team
might update it to use the newer names and fields. In such cases they will add an alias from the old
protocol name to the new one in order to make the transition easier.
For example, the DHCP dissector was originally developed for the BOOTP protocol but as of
Wireshark 3.0 all of the “bootp” display filter fields have been renamed to their “dhcp” equivalents.
You can still use the old filter names for the time being, e.g., “bootp.type” is equivalent to
“dhcp.type” but Wireshark will show the warning “"bootp" is deprecated” when you use it. Support
for the deprecated fields may be removed in the future.

Some protocol names can be ambiguous
In some particular cases relational expressions (equal, less than, etc.) can be ambiguous. The filter
name of a protocol or protocol field can contain any letter and digit in any order, possibly separated
by dots. That can be indistinguishable from a literal value (usually numerical values in
hexadecimal). For example the semantic value of fc can be the protocol Fibre Channel or the
number 0xFC in hexadecimal because the 0x prefix is optional for hexadecimal numbers.
Any value that matches a registered protocol or protocol field filter name is interpreted
semantically as such. If it doesn’t match a protocol name the normal rules for parsing literal values
apply.
So in the case of 'fc' the lexical token is interpreted as "Fibre Channel" and not 0xFC. In the case of
'fd' it would be interpreted as 0xFD because it is a well-formed hexadecimal literal value (according
to the rules of display filter language syntax) and there is no protocol registered with the filter
name 'fd'.

125

How ambiguous values are interpreted may change in the future. To avoid this problem and
resolve the ambiguity there is additional syntax available. Values prefixed with a dot are always
treated as a protocol name. The dot stands for the root of the protocol namespace and is optional).
Values prefixed with a colon are always interpreted as a byte array.

frame[10:] contains .fc or frame[10] == :fc
If you are writing a script, or you think your expression may not be giving the expected results
because of the syntactical ambiguity of some filter expression it is advisable to use the explicit
syntax to indicate the correct meaning for that expression.

The “Display Filter Expression” Dialog Box
When you are accustomed to Wireshark’s filtering system and know what labels you wish to use in
your filters it can be very quick to simply type a filter string. However, if you are new to Wireshark
or are working with a slightly unfamiliar protocol it can be very confusing to try to figure out what
to type. The “Display Filter Expression” dialog box helps with this.
TIP

The “Display Filter Expression” dialog box is an excellent way to learn how to write
Wireshark display filter strings.
check the screen below

Figure 62. The “Display Filter Expression” dialog box

126

When you first bring up the Display Filter Expression dialog box you are shown a tree of field
names, organized by protocol, and a box for selecting a relation.
Field Name
Select a protocol field from the protocol field tree. Every protocol with filterable fields is listed at
the top level. You can search for a particular protocol entry by entering the first few letters of the
protocol name. By expanding a protocol name you can get a list of the field names available for
filtering for that protocol.
Relation
Select a relation from the list of available relation. The is present is a unary relation which is
true if the selected field is present in a packet. All other listed relations are binary relations
which require additional data (e.g. a Value to match) to complete.
When you select a field from the field name list and select a binary relation (such as the equality
relation ==) you will be given the opportunity to enter a value, and possibly some range
information.
Value
You may enter an appropriate value in the Value text box. The Value will also indicate the type of
value for the Field Name you have selected (like character string).
Predefined Values
Some of the protocol fields have predefined values available, much like enumerations in C. If the
selected protocol field has such values defined, you can choose one of them here.
Search
Lets you search for a full or partial field name or description. Regular expressions are
supported. For example, searching for “tcp.*flag” shows the TCP flags fields supported by a wide
variety of dissectors, while “^tcp.flag” shows only the TCP flags fields supported by the TCP
dissector.
Range
A range of integers or a group of ranges, such as 1-12 or 39-42,98-2000.
[ Help ]
Opens this section of the User’s Guide.
[ OK ]
When you have built a satisfactory expression click [ OK ] and a filter string will be built for you.
[ Cancel ]
You can leave the “Add Expression…” dialog box without any effect by clicking the [ Cancel ]
button.

127

Defining And Saving Filters
You create pre-defined filters that appear in the capture and display filter bookmark menus ( ).
This can save time in remembering and retyping some of the more complex filters you use.
To create or edit capture filters, select Manage Capture Filters from the capture filter bookmark
menu or Capture › Capture Filters… from the main menu. Display filters can be created or edited
by selecting Manage Display Filters from the display filter bookmark menu or Analyze › Display
Filters… from the main menu. Wireshark will open the corresponding dialog as shown in The
“Capture Filters” and “Display Filters” dialog boxes. The two dialogs look and work similar to one
another. Both are described here, and the differences are noted as needed.

check the screen below

Figure 63. The “Capture Filters” and “Display Filters” dialog boxes

[+]
Adds a new filter to the list. You can edit the filter name or expression by double-clicking on it.
The filter name is used in this dialog to identify the filter for your convenience and is not used
elsewhere. You can create multiple filters with the same name, but this is not very useful.
When typing in a filter string, the background color will change depending on the validity of the
filter similar to the main capture and display filter toolbars.
[-]
Delete the selected filter. This will be greyed out if no filter is selected.
[ Copy ]
Copy the selected filter. This will be greyed out if no filter is selected.
128

[ OK ]
Saves the filter settings and closes the dialog.
[ Cancel ]
Closes the dialog without saving any changes.

Defining And Saving Filter Macros
You can define a filter macro with Wireshark and label it for later use. This can save time in
remembering and retyping some of the more complex filters you use.
To define and save your own filter macros, follow the steps below:
1. In the main menu select Analyze › Display Filter Macros…. Wireshark will open a
corresponding dialog Display Filter Macros window.

check the screen below

Figure 64. Display Filter Macros window

2. To add a new filter macro, click the [ + ] button in the bottom-left corner. A new row will appear
in the Display Filter Macros table above.
3. Enter the name of your macro in the Name column. Enter your filter macro in the Text column.
4. To save your modifications, click the [ OK ] button in the bottom-right corner of the Display
Filter Macros window.
To learn more about display filter macro syntax, see Display Filter Macros.


Finding Packets
You can easily find packets once you have captured some packets or have read in a previously
saved capture file. Simply select Edit › Find Packet… in the main menu. Wireshark will open a
toolbar between the main toolbar and the packet list shown in The “Find Packet” toolbar.

The “Find Packet” Toolbar
check the screen below


Figure 65. The “Find Packet” toolbar

You can search using the following criteria:
Display filter
Enter a display filter string into the text entry field and click the [ Find ] button. + For example,
to find the three-way handshake for a connection from host 192.168.0.1, use the following filter
string:

ip.src==192.168.0.1 and tcp.flags.syn==1
The value to be found will be syntax checked while you type it in. If the syntax check of your
value succeeds, the background of the entry field will turn green, if it fails, it will turn red. For
more details see Filtering Packets While Viewing
Hexadecimal Value
Search for a specific byte sequence in the packet data.
For example, use “ef:bb:bf” to find the next packet that contains the UTF-8 byte order mark.
String
Find a string in the packet data, with various options.
Regular Expression
Search the packet data using Perl-compatible regular expressions. PCRE patterns are beyond the
scope of this document, but typing “pcre test” into your favorite search engine should return a
number of sites that will help you test and explore your expressions.

Go To A Specific Packet
You can easily jump to specific packets with one of the menu items in the Go menu.

130

The “Go Back” Command
Go back in the packet history, works much like the page history in most web browsers.

The “Go Forward” Command
Go forward in the packet history, works much like the page history in most web browsers.

The “Go to Packet” Toolbar

check the screen below

Figure 66. The “Go To Packet” toolbar

This toolbar can be opened by selecting Go › Go to packet… from the main menu. It appears
between the main toolbar and the packet list, similar to the ”Find Packet” toolbar.
When you enter a packet number and press [ Go to packet ] Wireshark will jump to that packet.

The “Go to Corresponding Packet” Command
If a protocol field is selected which points to another packet in the capture file, this command will
jump to that packet.
As these protocol fields now work like links (just as in your Web browser), it’s easier to simply
double-click on the field to jump to the corresponding field.

The “Go to First Packet” Command
This command will jump to the first packet displayed.

The “Go to Last Packet” Command
This command will jump to the last packet displayed.

Marking Packets
You can mark packets in the “Packet List” pane. A marked packet will be shown with black
background, regardless of the coloring rules set. Marking a packet can be useful to find it later
while analyzing in a large capture file.
Marked packet information is not stored in the capture file or anywhere else. It will be lost when
the capture file is closed.

131

You can use packet marking to control the output of packets when saving, exporting, or printing. To
do so, an option in the packet range is available, see The “Packet Range” Frame.
There are several ways to mark and unmark packets. From the Edit menu you can select from the
following:
• Mark/Unmark Packet toggles the marked state of a single packet. This option is also available
in the packet list context menu.
• Mark All Displayed set the mark state of all displayed packets.
• Unmark All Displayed reset the mark state of all packets.
You can also mark and unmark a packet by clicking on it in the packet list with the middle mouse
button.

Ignoring Packets
You can ignore packets in the “Packet List” pane. Wireshark will then pretend that they not exist in
the capture file. An ignored packet will be shown with white background and grey foreground,
regardless of the coloring rules set.
Ignored packet information is not stored in the capture file or anywhere else. It will be lost when
the capture file is closed.
There are several ways to ignore and unignore packets. From the Edit menu you can select from
the following:
• Ignore/Unignore Packet toggles the ignored state of a single packet. This option is also
available in the packet list context menu.
• Ignore All Displayed set the ignored state of all displayed packets.
• Unignore All Displayed reset the ignored state of all packets.

Time Display Formats And Time References
While packets are captured, each packet is timestamped. These timestamps will be saved to the
capture file, so they will be available for later analysis.
A detailed description of timestamps, timezones and alike can be found at: Time Stamps.
The timestamp presentation format and the precision in the packet list can be chosen using the
View menu, see The “View” Menu.
The available presentation formats are:
• Date and Time of Day: 1970-01-01 01:02:03.123456 The absolute date and time of the day when
the packet was captured.

132

• Time of Day: 01:02:03.123456 The absolute time of the day when the packet was captured.
• Seconds Since First Captured Packet: 123.123456 The time relative to the start of the capture
file or the first “Time Reference” before this packet (see Packet Time Referencing).
• Seconds Since Previous Captured Packet: 1.123456 The time relative to the previous captured
packet.
• Seconds Since Previous Displayed Packet: 1.123456 The time relative to the previous
displayed packet.
• Seconds Since Epoch (1970-01-01): 1234567890.123456 The time relative to epoch (midnight
UTC of January 1, 1970).
The available precisions (aka. the number of displayed decimal places) are:
• Automatic (from capture file) The timestamp precision of the loaded capture file format will
be used (the default).
• Seconds, Tenths of a second, Hundredths of a second, Milliseconds, Microseconds or
Nanoseconds The timestamp precision will be forced to the given setting. If the actually
available precision is smaller, zeros will be appended. If the precision is larger, the remaining
decimal places will be cut off.
Precision example: If you have a timestamp and it’s displayed using, “Seconds Since Previous
Packet” the value might be 1.123456. This will be displayed using the “Automatic” setting for
libpcap files (which is microseconds). If you use Seconds it would show simply 1 and if you use
Nanoseconds it shows 1.123456000.

Packet Time Referencing
The user can set time references to packets. A time reference is the starting point for all subsequent
packet time calculations. It will be useful, if you want to see the time values relative to a special
packet, e.g., the start of a new request. It’s possible to set multiple time references in the capture
file.
The time references will not be saved permanently and will be lost when you close the capture file.
Time referencing will only be useful if the time display format is set to “Seconds Since First
Captured Packet”. If one of the other time display formats are used, time referencing will have no
effect (and will make no sense either).
To work with time references, choose one of the Time Reference items in the menu:[Edit] menu or
from the pop-up menu of the “Packet List” pane. See The “Edit” Menu.
• Set Time Reference (toggle) Toggles the time reference state of the currently selected packet to
on or off.
• Find Next Find the next time referenced packet in the “Packet List” pane.
• Find Previous Find the previous time referenced packet in the “Packet List” pane.

check the screen below
Figure 67. Wireshark showing a time referenced packet

A time referenced packet will be marked with the string *REF* in the Time column (see packet
number 10). All subsequent packets will show the time since the last time reference.

134

Advanced Topics
Introduction
This chapter will describe some of Wireshark’s advanced features.

Following Protocol Streams
It can be very helpful to see a protocol in the way that the application layer sees it. Perhaps you are
looking for passwords in a Telnet stream, or you are trying to make sense of a data stream. Maybe
you just need a display filter to show only the packets in a TLS or SSL stream. If so, Wireshark’s
ability to follow protocol streams will be useful to you.
To filter to a particular stream, select a TCP, UDP, DCCP, TLS, HTTP, HTTP/2, QUIC or SIP packet in the
packet list of the stream/connection you are interested in and then select the menu item Analyze ›
Follow › TCP Stream (or use the context menu in the packet list). Wireshark will set an appropriate
display filter and display a dialog box with the data from the stream laid out, as shown in The
“Follow TCP Stream” dialog box.
Following a protocol stream applies a display filter which selects all the packets in the
TIP

current stream. Some people open the “Follow TCP Stream” dialog and immediately
close it as a quick way to isolate a particular stream. Closing the dialog with the “Back”
button will reset the display filter if this behavior is not desired.
check the screen below

Figure 68. The “Follow TCP Stream” dialog box

The stream content is displayed in the same sequence as it appeared on the network. Non-printable
characters are replaced by dots. Traffic from the client to the server is colored red, while traffic

135

from the server to the client is colored blue. These colors can be changed by opening Edit ›
Preferences and under Appearance › Font and Colors, selecting different colors for the [ Sample
"Follow Stream" client text ] and [ Sample "Follow Stream" server text ] options.
The stream content won’t be updated while doing a live capture. To get the latest content you’ll
have to reopen the dialog.
You can choose from the following actions:
[ Help ]
Show this help.
[ Filter out this stream ]
Apply a display filter removing the current stream data from the display.
[ Print ]
Print the stream data in the currently selected format.
[ Save as… ]
Save the stream data in the currently selected format.
[ Back ]
Close this dialog box and restore the previous display filter.
[ Close ]
Close this dialog box, leaving the current display filter in effect.
By default, Wireshark displays both client and server data. You can select the Entire conversation
to switch between both, client to server, or server to client data.
You can choose to view the data in one of the following formats:
ASCII
In this view you see the data from each direction in ASCII. Obviously best for ASCII based
protocols, e.g., HTTP.
C Arrays
This allows you to import the stream data into your own C program.
EBCDIC
For the big-iron freaks out there.
HEX Dump
This allows you to see all the data. This will require a lot of screen space and is best used with
binary protocols.

136

UTF-8
Like ASCII, but decode the data as UTF-8.
UTF-16
Like ASCII, but decode the data as UTF-16.
YAML
This allows you to load the stream as YAML.
The YAML output is divided into 2 main sections:
• The peers section where for each peer you found the peer index, the host address and the port
number.
• The packets section where for each packet you found the packet number in the original capture,
the peer index, the packet index for this peer, the timestamp in seconds and the data in base64
encoding.
Example 3. Follow Stream YAML output

peers:
- peer: 0
host: 127.0.0.1
port: 54048
- peer: 1
host: 127.0.10.1
port: 5000
packets:
- packet: 1
peer: 0
index: 0
timestamp: 1599485409.693955274
data: !!binary |
aGVsbG8K
- packet: 3
peer: 1
index: 0
timestamp: 1599485423.885866692
data: !!binary |
Ym9uam91cgo=

The same example but in old YAML format (before version 3.5):

137

# Packet 1
peer0_0: !!binary |
aGVsbG8K
# Packet 3
peer1_0: !!binary |
Ym9uam91cgo=
How the old format data can be found in the new format:
New YAML format

...
packets:
- packet: AAA
peer: BBB
index: CCC
data: !!binary |
DDD

Old YAML format

# Packet AAA
peerBBB_CCC !!binary |
DDD

AAA: packet number in the
original capture
BBB: peer index
CCC: packet index for
this peer
DDD: data in base64
encoding

Raw
This allows you to load the unaltered stream data into a different program for further
examination. The display will look the same as the ASCII setting, but “Save As” will result in a
binary file.
You can switch between streams using the “Stream” selector.
You can search for text by entering it in the “Find” entry box and pressing [ Find Next ].

check the screen below

Figure 69. The “Follow HTTP/2 Stream” dialog box

138

The HTTP/2 Stream dialog is similar to the "Follow TCP Stream" dialog, except for an additional
"Substream" dialog field. HTTP/2 Streams are identified by a HTTP/2 Stream Index (field name
http2.streamid) which are unique within a TCP connection. The “Stream” selector determines the
TCP connection whereas the “Substream” selector is used to pick the HTTP/2 Stream ID.
The QUIC protocol is similar, the first number selects the QUIC connection number while the
"Substream" field selects the QUIC Stream ID.

check the screen below


Figure 70. The “Follow SIP Call” dialog box

The SIP call is shown with same dialog, just filter is based on sip.Call-ID field. Count of streams is
fixed to 0 and the field is disabled.

Show Packet Bytes
If a selected packet field does not show all the bytes (i.e., they are truncated when displayed) or if
they are shown as bytes rather than string or if they require more formatting because they contain
an image or HTML then this dialog can be used.
This dialog can also be used to decode field bytes from base64, zlib compressed or quoted-printable
and show the decoded bytes as configurable output. It’s also possible to select a subset of bytes
setting the start byte and end byte.
You can choose from the following actions:
[ Help ]
Show this help.
[ Print ]
Print the bytes in the currently selected format.

139

[ Copy ]
Copy the bytes to the clipboard in the currently selected format.
[ Save As ]
Save the bytes in the currently selected format.
[ Close ]
Close this dialog box.
You can choose to decode the data from one of the following formats:
None
This is the default which does not decode anything.
Base64
This will decode from Base64.
Compressed
This will decompress the buffer using zlib.
Hex Digits
This will decode from a string of hex digits. Non-hex characters are skipped.
Quoted-Printable
This will decode from a Quoted-Printable string.
ROT-13
This will decode ROT-13 encoded text.
You can choose to view the data in one of the following formats:
ASCII
In this view you see the bytes as ASCII. All control characters and non-ASCII bytes are replaced
by dot.
ASCII & Control
In this view all control characters are shown using a UTF-8 symbol and all non-ASCII bytes are
replaced by dot.
C Array
This allows you to import the field data into your own C program.
EBCDIC
For the big-iron freaks out there.

140

Hex Dump
This allows you to see all the data. This will require a lot of screen space and is best used with
binary protocols.
HTML
This allows you to see all the data formatted as a HTML document. The HTML supported is
what’s supported by the Qt QTextEdit class.
Image
This will try to convert the bytes into an image. Most popular formats are supported including
PNG, JPEG, GIF, and BMP.
ISO 8859-1
In this view you see the bytes as ISO 8859-1.
Raw
This allows you to load the unaltered stream data into a different program for further
examination. The display will show HEX data, but “Save As” will result in a binary file.
UTF-8
In this view you see the bytes as UTF-8.
UTF-16
In this view you see the bytes as UTF-16.
YAML
This will show the bytes as a YAML binary dump.
You can search for text by entering it in the “Find” entry box and pressing [ Find Next ].

Expert Information
Wireshark keeps track of any anomalies and other items of interest it finds in a capture file and
shows them in the Expert Information dialog. The goal is to give you a better idea of uncommon or
notable network behavior and to let novice and expert users find network problems faster than
manually scanning through the packet list.
Expert information is only a hint

Expert information is the starting point for investigation, not the stopping
WARNING

point. Every network is different, and it’s up to you to verify that Wireshark’s
expert information applies to your particular situation. The presence of expert
information doesn’t necessarily indicate a problem and absence of expert
information doesn’t necessarily mean everything is OK.

141

The amount of expert information largely depends on the protocol being used. While dissectors for
some common protocols like TCP and IP will show detailed information, other dissectors will show
little or none.
The following describes the components of a single expert information entry along with the expert
user interface.

Expert Information Entries
Expert information entries are grouped by severity level (described below) and contain the
following:
Table 27. Example expert information items

Packet #

Summary

Group

Protocol

592

TCP: [TCP Out-Of-

Malformed

TCP

Protocol

DNS

Sequence

TCP

Order] …
1202

DNS: Standard query
response …

443

TCP: 80 → 59322 [RST]
Seq=12761 Win=0
Len=0

Severity
Every expert information item has a severity level. The following levels are used, from lowest to
highest. Wireshark marks them using different colors, which are shown in parentheses:
Chat (blue)
Information about usual workflow, e.g., a TCP packet with the SYN flag set.
Note (cyan)
Notable events, e.g., an application returned a common error code such as HTTP 404.
Warn (yellow)
Warnings, e.g., application returned an unusual error code like a connection problem.
Error (red)
Serious problems, such as malformed packets.
Summary
Short explanatory text for each expert information item.

142

Group
Along with severity levels, expert information items are categorized by group. The following groups
are currently implemented:
Assumption
The protocol field has incomplete data and was dissected based on assumed value.
Checksum
A checksum was invalid.
Comment
Packet comment.
Debug
Debugging information. You shouldn’t see this group in release versions of Wireshark.
Decryption
A decryption issue.
Deprecated
The protocol field has been deprecated.
Malformed
Malformed packet or dissector has a bug. Dissection of this packet aborted.
Protocol
Violation of a protocol’s specification (e.g., invalid field values or illegal lengths). Dissection of
this packet probably continued.
Reassemble
Problems while reassembling, e.g., not all fragments were available or an exception happened
during reassembly.
Request Code
An application request (e.g., File Handle == x). Usually assigned the Chat severity level.
Response Code
An application response code indicates a potential problem, e.g., HTTP 404 page not found.
Security
A security problem, e.g., an insecure implementation.
Sequence
A protocol sequence number was suspicious, e.g., it wasn’t continuous or a retransmission was
detected.
143

Undecoded
Dissection incomplete or data can’t be decoded for other reasons.
It’s possible that more groups will be added in the future.
Protocol
The protocol dissector that created the expert information item.

The “Expert Information” Dialog
You can open the expert info dialog by selecting Analyze › Expert Info or by clicking the expert
level indicator in the main status bar.
Right-clicking on an item will allow you to apply or prepare a filter based on the item, copy its
summary text, and other tasks.
check the screen below
Figure 71. The “Expert Information” dialog box

You can choose from the following actions:
Limit to display filter
Only show expert information items present in packets that match the current display filter.
Group by summary
Group items by their summary instead of the groups described above.
Search
Only show items that match the search string, such as “dns”. Regular expressions are supported.

144

Show…
Lets you show or hide each severity level. For example, you can deselect Chat and Note
severities if desired.
[ Help ]
Takes you to this section of the User’s Guide.
[ Close ]
Closes the dialog

“Colorized” Protocol Details Tree
check the screen below

Figure 72. The “Colorized” protocol details tree

The packet detail tree marks fields with expert information based on their severity level color, e.g.,
“Warning” severities have a yellow background. This color is propagated to the top-level protocol
item in the tree in order to make it easy to find the field that created the expert information.
For the example screenshot above, the IP “Time to live” value is very low (only 1), so the
corresponding protocol field is marked with a cyan background. To make it easier find that item in
the packet tree, the IP protocol toplevel item is marked cyan as well.

“Expert” Packet List Column (Optional)

check the screen below
Figure 73. The “Expert” packet list column

An optional “Expert Info Severity” packet list column is available that displays the most significant
severity of a packet or stays empty if everything seems OK. This column is not displayed by default
but can be easily added using the Preferences Columns page described in Preferences.

TCP Analysis
By default, Wireshark’s TCP dissector tracks the state of each TCP session and provides additional
information when problems or potential problems are detected. Analysis is done once for each TCP
packet when a capture file is first opened. Packets are processed in the order in which they appear
in the packet list. You can enable or disable this feature via the “Analyze TCP sequence numbers”
TCP dissector preference.
For analysis of data or protocols layered on top of TCP (such as HTTP), see TCP Reassembly.

check the screen below

Figure 74. “TCP Analysis” packet detail items

TCP Analysis flags are added to the TCP protocol tree under “SEQ/ACK analysis”. Each flag is
described below. Terms such as “next expected sequence number” and “next expected
acknowledgment number” refer to the following”:

146

Next expected sequence number
The last-seen sequence number plus segment length. Set when there are no analysis flags and
for zero window probes. This is initially zero and calculated based on the previous packet in the
same TCP flow. Note that this may not be the same as the tcp.nxtseq protocol field.
Next expected acknowledgment number
The last-seen sequence number for segments. Set when there are no analysis flags and for zero
window probes.
Last-seen acknowledgment number
Always set. Note that this is not the same as the next expected acknowledgment number.
Last-seen acknowledgment number
Always updated for each packet. Note that this is not the same as the next expected
acknowledgment number.

TCP ACKed unseen segment
Set when the expected next acknowledgment number is set for the reverse direction and it’s less
than the current acknowledgment number.

TCP Dup ACK <frame>#<acknowledgment number>
Set when all of the following are true:
• The segment size is zero.
• The window size is non-zero and hasn’t changed.
• The next expected sequence number and last-seen acknowledgment number are non-zero (i.e.,
the connection has been established).
• SYN, FIN, and RST are not set.

TCP Fast Retransmission
Set when all of the following are true:
• This is not a keepalive packet.
• In the forward direction, the segment size is greater than zero or the SYN or FIN is set.
• The next expected sequence number is greater than the current sequence number.
• We have more than two duplicate ACKs in the reverse direction.
• The current sequence number equals the next expected acknowledgment number.
• We saw the last acknowledgment less than 20ms ago.
Supersedes “Out-Of-Order” and “Retransmission”.
147

TCP Keep-Alive
Set when the segment size is zero or one, the current sequence number is one byte less than the
next expected sequence number, and none of SYN, FIN, or RST are set.
Supersedes

“Fast

Retransmission”,

“Out-Of-Order”,

“Spurious

Retransmission”,

and

“Retransmission”.

TCP Keep-Alive ACK
Set when all of the following are true:
• The segment size is zero.
• The window size is non-zero and hasn’t changed.
• The current sequence number is the same as the next expected sequence number.
• The current acknowledgment number is the same as the last-seen acknowledgment number.
• The most recently seen packet in the reverse direction was a keepalive.
• The packet is not a SYN, FIN, or RST.
Supersedes “Dup ACK” and “ZeroWindowProbeAck”.

TCP Out-Of-Order
Set when all of the following are true:
• This is not a keepalive packet.
• In the forward direction, the segment length is greater than zero or the SYN or FIN is set.
• The next expected sequence number is greater than the current sequence number.
• The next expected sequence number and the next sequence number differ.
• The last segment arrived within the Out-Of-Order RTT threshold. The threshold is either the
value shown in the “iRTT” (tcp.analysis.initial_rtt) field under “SEQ/ACK analysis” if it is present,
or the default value of 3ms if it is not.
Supersedes “Retransmission”.

TCP Port numbers reused
Set when the SYN flag is set (not SYN+ACK), we have an existing conversation using the same
addresses and ports, and the sequence number is different than the existing conversation’s initial
sequence number.

TCP Previous segment not captured

148

Set when the current sequence number is greater than the next expected sequence number.

TCP Spurious Retransmission
Checks for a retransmission based on analysis data in the reverse direction. Set when all of the
following are true:
• The SYN or FIN flag is set.
• This is not a keepalive packet.
• The segment length is greater than zero.
• Data for this flow has been acknowledged. That is, the last-seen acknowledgment number has
been set.
• The next sequence number is less than or equal to the last-seen acknowledgment number.
Supersedes “Fast Retransmission”, “Out-Of-Order”, and “Retransmission”.

TCP Retransmission
Set when all of the following are true:
• This is not a keepalive packet.
• In the forward direction, the segment length is greater than zero or the SYN or FIN flag is set.
• The next expected sequence number is greater than the current sequence number.

TCP Window Full
Set when the segment size is non-zero, we know the window size in the reverse direction, and our
segment size exceeds the window size in the reverse direction.

TCP Window Update
Set when the all of the following are true:
• The segment size is zero.
• The window size is non-zero and not equal to the last-seen window size.
• The sequence number is equal to the next expected sequence number.
• The acknowledgment number is equal to the last-seen acknowledgment number.
• None of SYN, FIN, or RST are set.

TCP ZeroWindow
Set when the receive window size is zero and none of SYN, FIN, or RST are set.

149

The window field in each TCP header advertises the amount of data a receiver can accept. If the
receiver can’t accept any more data it will set the window value to zero, which tells the sender to
pause its transmission. In some specific cases this is normal — for example, a printer might use a
zero window to pause the transmission of a print job while it loads or reverses a sheet of paper.
However, in most cases this indicates a performance or capacity problem on the receiving end. It
might take a long time (sometimes several minutes) to resume a paused connection, even if the
underlying condition that caused the zero window clears up quickly.

TCP ZeroWindowProbe
Set when the sequence number is equal to the next expected sequence number, the segment size is
one, and last-seen window size in the reverse direction was zero.
If the single data byte from a Zero Window Probe is dropped by the receiver (not ACKed), then a
subsequent segment should not be flagged as retransmission if all of the following conditions are
true for that segment: * The segment size is larger than one. * The next expected sequence number
is one less than the current sequence number.
This affects “Fast Retransmission”, “Out-Of-Order”, or “Retransmission”.

TCP ZeroWindowProbeAck
Set when the all of the following are true:
• The segment size is zero.
• The window size is zero.
• The sequence number is equal to the next expected sequence number.
• The acknowledgment number is equal to the last-seen acknowledgment number.
• The last-seen packet in the reverse direction was a zero window probe.
Supersedes “TCP Dup ACK”.

TCP Ambiguous Interpretations
Some captures are quite difficult to analyze automatically, particularly when the time frame may
cover both Fast Retransmission and Out-Of-Order packets. A TCP preference allows to switch the
precedence of these two interpretations at the protocol level.

TCP Conversation Completeness
TCP conversations are said to be complete when they have both opening and closing handshakes,
independently of any data transfer. However, we might be interested in identifying complete
conversations with some data sent, and we are using the following bit values to build a filter value
on the tcp.completeness field :

150

• 1 : SYN
• 2 : SYN-ACK
• 4 : ACK
• 8 : DATA
• 16 : FIN
• 32 : RST
For example, a conversation containing only a three-way handshake will be found with the filter
'tcp.completeness==7' (1+2+4) while a complete conversation with data transfer will be found with
a longer filter as closing a connection can be associated with FIN or RST packets, or even both :
'tcp.completeness==31 or tcp.completeness==47 or tcp.completeness==63'

Time Stamps
Time stamps, their precisions and all that can be quite confusing. This section will provide you with
information about what’s going on while Wireshark processes time stamps.
While packets are captured, each packet is time stamped as it comes in. These time stamps will be
saved to the capture file, so they also will be available for (later) analysis.
So where do these time stamps come from? While capturing, Wireshark gets the time stamps from
the libpcap (Npcap) library, which in turn gets them from the operating system kernel. If the
capture data is loaded from a capture file, Wireshark obviously gets the data from that file.

Wireshark Internals
The internal format that Wireshark uses to keep a packet time stamp consists of the date (in days
since 1.1.1970) and the time of day (in nanoseconds since midnight). You can adjust the way
Wireshark displays the time stamp data in the packet list, see the “Time Display Format” item in the
The “View” Menu for details.
While reading or writing capture files, Wireshark converts the time stamp data between the
capture file format and the internal format as required.
While capturing, Wireshark uses the libpcap (Npcap) capture library which supports microsecond
resolution. Unless you are working with specialized capturing hardware, this resolution should be
adequate.

Capture File Formats
Every capture file format that Wireshark knows supports time stamps. The time stamp precision
supported by a specific capture file format differs widely and varies from one second “0” to one
nanosecond “0.123456789”. Most file formats store the time stamps with a fixed precision (e.g.,
microseconds), while some file formats are even capable of storing the time stamp precision itself

151

(whatever the benefit may be).
The common libpcap capture file format that is used by Wireshark (and a lot of other tools)
supports a fixed microsecond resolution “0.123456” only.
Writing data into a capture file format that doesn’t provide the capability to store the actual
precision will lead to loss of information. For example, if you load a capture file with nanosecond
resolution and store the capture data in a libpcap file (with microsecond resolution) Wireshark
obviously must reduce the precision from nanosecond to microsecond.

Accuracy
People often ask “Which time stamp accuracy is provided by Wireshark?”. Well, Wireshark doesn’t
create any time stamps itself but simply gets them from “somewhere else” and displays them. So
accuracy will depend on the capture system (operating system, performance, etc.) that you use.
Because of this, the above question is difficult to answer in a general way.
USB connected network adapters often provide a very bad time stamp accuracy. The
incoming packets have to take “a long and winding road” to travel through the USB
NOTE

cable until they actually reach the kernel. As the incoming packets are time stamped
when they are processed by the kernel, this time stamping mechanism becomes
very inaccurate.
Don’t use USB connected NICs when you need precise time stamp accuracy.

Time Zones
If you travel across the planet, time zones can be confusing. If you get a capture file from
somewhere around the world time zones can even be a lot more confusing ;-)
First of all, there are two reasons why you may not need to think about time zones at all:
• You are only interested in the time differences between the packet time stamps and don’t need
to know the exact date and time of the captured packets (which is often the case).
• You don’t get capture files from different time zones than your own, so there are simply no time
zone problems. For example, everyone in your team is working in the same time zone as
yourself.

152

What are time zones?
People expect that the time reflects the sunset. Dawn should be in the morning maybe around
06:00 and dusk in the evening maybe at 20:00. These times will obviously vary depending on
the season. It would be very confusing if everyone on earth would use the same global time
as this would correspond to the sunset only at a small part of the world.
For that reason, the earth is split into several different time zones, each zone with a local time
that corresponds to the local sunset.
The time zone’s base time is UTC (Coordinated Universal Time) or Zulu Time (military and
aviation). The older term GMT (Greenwich Mean Time) shouldn’t be used as it is slightly
incorrect (up to 0.9 seconds difference to UTC). The UTC base time equals to 0 (based at
Greenwich, England) and all time zones have an offset to UTC between -12 to +14 hours!
For example: If you live in Berlin, you are in a time zone one hour earlier than UTC, so you
are in time zone “+1” (time difference in hours compared to UTC). If it’s 3 o’clock in Berlin it’s
2 o’clock in UTC “at the same moment”.
Be aware that at a few places on earth don’t use time zones with even hour offsets (e.g., New
Delhi uses UTC+05:30)!
Further

information

can

be

found

at:

https://en.wikipedia.org/wiki/Time_zone

and

https://en.wikipedia.org/wiki/Coordinated_Universal_Time.

What is daylight saving time (DST)?
Daylight Saving Time (DST), also known as Summer Time is intended to “save” some daylight
during the summer months. To do this, a lot of countries (but not all!) add a DST hour to the
already existing UTC offset. So you may need to take another hour (or in very rare cases even
two hours!) difference into your “time zone calculations”.
Unfortunately, the date at which DST actually takes effect is different throughout the world.
You may also note, that the northern and southern hemispheres have opposite DST’s (e.g.,
while it’s summer in Europe it’s winter in Australia).
Keep in mind: UTC remains the same all year around, regardless of DST!
Further information can be found at https://en.wikipedia.org/wiki/Daylight_saving.
Further time zone and DST information can be found at https://wwp.greenwichmeantime.com/ and
https://www.timeanddate.com/worldclock/.

Set your computer’s time correctly!

153

If you work with people around the world it’s very helpful to set your computer’s time and time
zone right.
You should set your computers time and time zone in the correct sequence:
1. Set your time zone to your current location
2. Set your computer’s clock to the local time
This way you will tell your computer both the local time and also the time offset to UTC. Many
organizations simply set the time zone on their servers and networking gear to UTC in order to
make coordination and troubleshooting easier.
If you travel around the world, it’s an often-made mistake to adjust the hours of your
TIP

computer clock to the local time. Don’t adjust the hours but your time zone setting
instead! For your computer, the time is essentially the same as before, you are simply
in a different time zone with a different local time.

You can use the Network Time Protocol (NTP) to automatically adjust your computer to the correct
time, by synchronizing it to Internet NTP clock servers. NTP clients are available for all operating
systems that Wireshark supports (and for a lot more), for examples see http://www.ntp.org/.

Wireshark and Time Zones
So what’s the relationship between Wireshark and time zones anyway?
Wireshark’s native capture file format (libpcap format), and some other capture file formats, such
as the Windows Sniffer, *Peek, Sun snoop formats, and newer versions of the Microsoft Network
Monitor and Network Instruments/Viavi Observer formats, save the arrival time of packets as UTC
values. UN*X systems, and “Windows NT based” systems represent time internally as UTC. When
Wireshark is capturing, no conversion is necessary. However, if the system time zone is not set
correctly, the system’s UTC time might not be correctly set even if the system clock appears to
display correct local time. When capturing, Npcap has to convert the time to UTC before supplying
it to Wireshark. If the system’s time zone is not set correctly, that conversion will not be done
correctly.
Other capture file formats, such as the OOS-based Sniffer format and older versions of the
Microsoft Network Monitor and Network Instruments/Viavi Observer formats, save the arrival time
of packets as local time values.
Internally to Wireshark, time stamps are represented in UTC. This means that when reading
capture files that save the arrival time of packets as local time values, Wireshark must convert
those local time values to UTC values.
Wireshark in turn will display the time stamps always in local time. The displaying computer will
convert them from UTC to local time and displays this (local) time. For capture files saving the
arrival time of packets as UTC values, this means that the arrival time will be displayed as the local

154

time in your time zone, which might not be the same as the arrival time in the time zone in which
the packet was captured. For capture files saving the arrival time of packets as local time values, the
conversion to UTC will be done using your time zone’s offset from UTC and DST rules, which means
the conversion will not be done correctly; the conversion back to local time for display might undo
this correctly, in which case the arrival time will be displayed as the arrival time in which the
packet was captured.
Table 28. Time zone examples for UTC arrival times (without DST)

Capture File

Los Angeles New York

Madrid

London

Berlin

Tokyo

10:00

10:00

10:00

10:00

10:00

10:00

-8

-5

-1

0

+1

+9

02:00

05:00

09:00

10:00

11:00

19:00

(UTC)
Local Offset
to UTC
Displayed
Time (Local
Time)
For example, let’s assume that someone in Los Angeles captured a packet with Wireshark at exactly
2 o’clock local time and sends you this capture file. The capture file’s time stamp will be
represented in UTC as 10 o’clock. You are located in Berlin and will see 11 o’clock on your
Wireshark display.
Now you have a phone call, video conference or Internet meeting with that one to talk about that
capture file. As you are both looking at the displayed time on your local computers, the one in Los
Angeles still sees 2 o’clock but you in Berlin will see 11 o’clock. The time displays are different as
both Wireshark displays will show the (different) local times at the same point in time.
Conclusion: You may not bother about the date/time of the time stamp you currently look at unless
you must make sure that the date/time is as expected. So, if you get a capture file from a different
time zone and/or DST, you’ll have to find out the time zone/DST difference between the two local
times and “mentally adjust” the time stamps accordingly. In any case, make sure that every
computer in question has the correct time and time zone setting.

Packet Reassembly
What Is It?
Network protocols often need to transport large chunks of data which are complete in themselves,
e.g., when transferring a file. The underlying protocol might not be able to handle that chunk size
(e.g., limitation of the network packet size), or is stream-based like TCP, which doesn’t know data
chunks at all.
In that case the network protocol has to handle the chunk boundaries itself and (if required) spread
the data over multiple packets. It obviously also needs a mechanism to determine the chunk
155

boundaries on the receiving side.
Wireshark calls this mechanism reassembly, although a specific protocol specification might use a
different term for this (e.g., desegmentation, defragmentation, etc.).

How Wireshark Handles It
For some of the network protocols Wireshark knows of, a mechanism is implemented to find,
decode and display these chunks of data. Wireshark will try to find the corresponding packets of
this chunk, and will show the combined data as additional tabs in the “Packet Bytes” pane (for
information about this pane. See The “Packet Bytes” Pane).

check the screen below

Figure 75. The “Packet Bytes” pane with a reassembled tab

Reassembly might take place at several protocol layers, so it’s possible that multiple tabs in the
“Packet Bytes” pane appear.
NOTE

You will find the reassembled data in the last packet of the chunk.

For example, in a HTTP GET response, the requested data (e.g., an HTML page) is returned.
Wireshark will show the hex dump of the data in a new tab “Uncompressed entity body” in the
“Packet Bytes” pane.
Reassembly is enabled in the preferences by default but can be disabled in the preferences for the
protocol in question. Enabling or disabling reassembly settings for a protocol typically requires two
things:
1. The lower-level protocol (e.g., TCP) must support reassembly. Often this reassembly can be
enabled or disabled via the protocol preferences.
2. The higher-level protocol (e.g., HTTP) must use the reassembly mechanism to reassemble
fragmented protocol data. This too can often be enabled or disabled via the protocol
preferences.
The tooltip of the higher-level protocol setting will notify you if and which lower-level protocol
setting also has to be considered.

TCP Reassembly
Protocols such as HTTP or TLS are likely to span multiple TCP segments. The TCP protocol
preference “Allow subdissector to reassemble TCP streams” (enabled by default) makes it possible

156

for Wireshark to collect a contiguous sequence of TCP segments and hand them over to the higherlevel protocol (for example, to reconstruct a full HTTP message). All but the final segment will be
marked with “[TCP segment of a reassembled PDU]” in the packet list.
Disable this preference to reduce memory and processing overhead if you are only interested in
TCP sequence number analysis (TCP Analysis). Keep in mind, though, that higher-level protocols
might be wrongly dissected. For example, HTTP messages could be shown as “Continuation” and
TLS records could be shown as “Ignored Unknown Record”. Such results can also be observed if you
start capturing while a TCP connection was already started or when TCP segments are lost or
delivered out-of-order.
To reassemble of out-of-order TCP segments, the TCP protocol preference “Reassemble out-of-order
segments” (currently disabled by default) must be enabled in addition to the previous preference. If
all packets are received in-order, this preference will not have any effect. Otherwise (if missing
segments are encountered while sequentially processing a packet capture), it is assuming that the
new and missing segments belong to the same PDU. Caveats:
• Lost packets are assumed to be received out-of-order or retransmitted later. Applications
usually retransmit segments until these are acknowledged, but if the packet capture drops
packets, then Wireshark will not be able to reconstruct the TCP stream. In such cases, you can
try to disable this preference and hopefully have a partial dissection instead of seeing just “[TCP
segment of a reassembled PDU]” for every TCP segment.
• When doing a capture in monitor mode (IEEE 802.11), packets are more likely to get lost due to
signal reception issues. In that case it is recommended to disable the option.
• If the new and missing segments are in fact part of different PDUs, then processing is currently
delayed until no more segments are missing, even if the begin of the missing segments
completed a PDU. For example, assume six segments forming two PDUs ABC and DEF. When
received as ABECDF, an application can start processing the first PDU after receiving ABEC.
Wireshark however requires the missing segment D to be received as well. This issue will be
addressed in the future.
• In the GUI and during a two-pass dissection (tshark -2), the previous scenario will display both
PDUs in the packet with last segment (F) rather than displaying it in the first packet that has the
final missing segment of a PDU. This issue will be addressed in the future.
• When enabled, fields such as the SMB “Time from request” (smb.time) might be smaller if the
request follows other out-of-order segments (this reflects application behavior). If the previous
scenario however occurs, then the time of the request is based on the frame where all missing
segments are received.
Regardless of the setting of these two reassembly-related preferences, you can always use the
“Follow TCP Stream” option (Following Protocol Streams) which displays segments in the expected
order.

157

Name Resolution
Name resolution tries to convert some of the numerical address values into a human readable
format. There are two possible ways to do these conversions, depending on the resolution to be
done: calling system/network services (like the gethostname() function) and/or resolving from
Wireshark specific configuration files. For details about the configuration files Wireshark uses for
name resolution and alike, see Files and Folders.
The name resolution feature can be enabled individually for the protocol layers listed in the
following sections.

Name Resolution Drawbacks
Name resolution can be invaluable while working with Wireshark and may even save you hours of
work. Unfortunately, it also has its drawbacks.
• Name resolution can often fail. The name to be resolved might simply be unknown by the name
servers asked, or the servers are just not available and the name is also not found in
Wireshark’s configuration files.
• Resolved names might not be available. Wireshark obtains name resolution information from a
variety of sources, including DNS servers, the capture file itself (e.g., for a pcapng file), and the
hosts files on your system and in your profile directory. The resolved names might not be
available if you open the capture file later or on a different machine. As a result, each time you
or someone else opens a particular capture file it may look slightly different due to changing
environments.
• DNS may add additional packets to your capture file. You might run into the observer effect if the
extra traffic from Wireshark’s DNS queries and responses affects the problem you’re trying to
troubleshoot or any subsequent analysis.
The same sort of thing can happen when capturing over a remote connection, e.g., SSH or RDP.
• Resolved DNS names are cached by Wireshark. This is required for acceptable performance.
However, if the name resolution information should change while Wireshark is running,
Wireshark won’t notice a change in the name resolution information once it gets cached. If this
information changes while Wireshark is running, e.g., a new DHCP lease takes effect, Wireshark
won’t notice it.
Name resolution in the packet list is done while the list is filled. If a name can be resolved after a
packet is added to the list, its former entry won’t be changed. As the name resolution results are
cached, you can use View › Reload to rebuild the packet list with the correctly resolved names.
However, this isn’t possible while a capture is in progress.

158

Ethernet Name Resolution (MAC Layer)
Try to resolve an Ethernet MAC address (e.g., 00:09:5b:01:02:03) to a human readable name.
ARP name resolution (system service): Wireshark will ask the operating system to convert an
Ethernet address to the corresponding IP address (e.g. 00:09:5b:01:02:03 → 192.168.0.1).
Ethernet codes (ethers file): If the ARP name resolution failed, Wireshark tries to convert the
Ethernet address to a known device name, which has been assigned by the user using an ethers file
(e.g., 00:09:5b:01:02:03 → homerouter).
Ethernet manufacturer codes (manuf file): If neither ARP or ethers returns a result, Wireshark tries
to convert the first 3 bytes of an ethernet address to an abbreviated manufacturer name, which has
been assigned by the IEEE (e.g. 00:09:5b:01:02:03 → Netgear_01:02:03).

IP Name Resolution (Network Layer)
Try to resolve an IP address (e.g., 216.239.37.99) to a human readable name.
DNS name resolution (system/library service): Wireshark will use a name resolver to convert an IP
address to the hostname associated with it (e.g., 216.239.37.99 → www.1.google.com).
Most applications use synchronously DNS name resolution. For example, your web browser must
resolve the host name portion of a URL before it can connect to the server. Capture file analysis is
different. A given file might have hundreds, thousands, or millions of IP addresses so for usability
and performance reasons Wireshark uses asynchronous resolution. Both mechanisms convert IP
addresses to human readable (domain) names and typically use different sources such as the
system hosts file (/etc/hosts) and any configured DNS servers.
Since Wireshark doesn’t wait for DNS responses, the host name for a given address might be
missing from a given packet when you view it the first time but be present when you view it
subsequent times.
You can adjust name resolution behavior in the Name Resolution section in the Preferences Dialog.
You can control resolution itself by adding a hosts file to your personal configuration directory. You
can also edit your system hosts file, but that isn’t generally recommended.

TCP/UDP Port Name Resolution (Transport Layer)
Try to resolve a TCP/UDP port (e.g., 80) to a human readable name.
TCP/UDP port conversion (system service): Wireshark will ask the operating system to convert a TCP
or UDP port to its well-known name (e.g., 80 → http).

VLAN ID Resolution
To get a descriptive name for a VLAN tag ID a vlans file can be used.

159

SS7 Point Code Resolution
To get a node name for a SS7 point code a ss7pcs file can be used.

Checksums
Several network protocols use checksums to ensure data integrity. Applying checksums as
described here is also known as redundancy checking.

What are checksums for?
Checksums are used to ensure the integrity of data portions for data transmission or storage.
A checksum is basically a calculated summary of such a data portion.
Network data transmissions often produce errors, such as toggled, missing or duplicated bits.
As a result, the data received might not be identical to the data transmitted, which is
obviously a bad thing.
Because of these transmission errors, network protocols very often use checksums to detect
such errors. The transmitter will calculate a checksum of the data and transmits the data
together with the checksum. The receiver will calculate the checksum of the received data
with the same algorithm as the transmitter. If the received and calculated checksums don’t
match a transmission error has occurred.
Some checksum algorithms are able to recover (simple) errors by calculating where the
expected error must be and repairing it.
If there are errors that cannot be recovered, the receiving side throws away the packet.
Depending on the network protocol, this data loss is simply ignored or the sending side needs
to detect this loss somehow and retransmits the required packet(s).
Using a checksum drastically reduces the number of undetected transmission errors.
However, the usual checksum algorithms cannot guarantee an error detection of 100%, so a
very small number of transmission errors may remain undetected.
There are several different kinds of checksum algorithms; an example of an often used
checksum algorithm is CRC32. The checksum algorithm actually chosen for a specific network
protocol will depend on the expected error rate of the network medium, the importance of
error detection, the processor load to perform the calculation, the performance needed and
many other things.
Further information about checksums can be found at: https://en.wikipedia.org/wiki/
Checksum.

160

Wireshark Checksum Validation
Wireshark will validate the checksums of many protocols, e.g., IP, TCP, UDP, etc.
It will do the same calculation as a “normal receiver” would do, and shows the checksum fields in
the packet details with a comment, e.g., [correct] or [invalid, must be 0x12345678].
Checksum validation can be switched off for various protocols in the Wireshark protocol
preferences, e.g., to (very slightly) increase performance.
If the checksum validation is enabled and it detected an invalid checksum, features like packet
reassembly won’t be processed. This is avoided as incorrect connection data could “confuse” the
internal database.

Checksum Offloading
The checksum calculation might be done by the network driver, protocol driver or even in
hardware.
For example: The Ethernet transmitting hardware calculates the Ethernet CRC32 checksum and the
receiving hardware validates this checksum. If the received checksum is wrong Wireshark won’t
even see the packet, as the Ethernet hardware internally throws away the packet.
Higher-level checksums are “traditionally” calculated by the protocol implementation and the
completed packet is then handed over to the hardware.
Recent network hardware can perform advanced features such as IP checksum calculation, also
known as checksum offloading. The network driver won’t calculate the checksum itself but will
simply hand over an empty (zero or garbage filled) checksum field to the hardware.
Checksum offloading often causes confusion as the network packets to be
transmitted are handed over to Wireshark before the checksums are actually
NOTE

calculated. Wireshark gets these “empty” checksums and displays them as invalid,
even though the packets will contain valid checksums when they leave the network
hardware later.

Checksum offloading can be confusing and having a lot of [invalid] messages on the screen can be
quite annoying. As mentioned above, invalid checksums may lead to unreassembled packets,
making the analysis of the packet data much harder.
You can do two things to avoid this checksum offloading problem:
• Turn off the checksum offloading in the network driver, if this option is available.
• Turn off checksum validation of the specific protocol in the Wireshark preferences. Recent
releases of Wireshark disable checksum validation by default due to the prevalence of
offloading in modern hardware and operating systems.

161

Statistics
Introduction
Wireshark provides a wide range of network statistics which can be accessed via the Statistics
menu.
These statistics range from general information about the loaded capture file (like the number of
captured packets), to statistics about specific protocols (e.g., statistics about the number of HTTP
requests and responses captured).
General statistics

• Capture File Properties about the capture file.
• Protocol Hierarchy of the captured packets.
• Conversations e.g., traffic between specific IP addresses.
• Endpoints e.g., traffic to and from IP addresses.
• I/O Graphs visualizing the number of packets (or similar) in time.
Protocol specific statistics

• Service Response Time between request and response of some protocols.
• Various other protocol specific statistics.
The protocol specific statistics require detailed knowledge about the specific
NOTE

protocol. Unless you are familiar with that protocol, statistics about it may be
difficult to understand.

Wireshark has many other statistics windows that display detailed information about specific
protocols and might be described in a later version of this document.
Some of these statistics are described at https://gitlab.com/wireshark/wireshark/-/wikis/Statistics.

The “Capture File Properties” Dialog
General information about the current capture file.

check the screen below
Figure 76. The “Capture File Properties” dialog

This dialog shows the following information:
Details
Notable information about the capture file.
File
General information about the capture file, including its full path, size, cryptographic hashes,
file format, and encapsulation.
Time
The timestamps of the first and the last packet in the file along with their difference.

163

Capture
Information about the capture environment. This will only be shown for live captures or if
this information is present in a saved capture file. The pcapng format supports this, while
pcap doesn’t.
Interfaces
Information about the capture interface or interfaces.
Statistics
A statistical summary of the capture file. If a display filter is set, you will see values in the
Captured column, and if any packets are marked, you will see values in the Marked column.
The values in the Captured column will remain the same as before, while the values in the
Displayed column will reflect the values corresponding to the packets shown in the display.
The values in the Marked column will reflect the values corresponding to the marked
packages.
Capture file comments
Some capture file formats (notably pcapng) allow a text comment for the entire file. You can
view and edit this comment here.
[ Refresh ]
Updates the information in the dialog.
[ Save Comments ]
Saves the contents of the “Capture file comments” text entry.
[ Close ]
Closes the dialog
[ Copy To Clipboard ]
Copies the “Details” information to the clipboard.
[ Help ]
Opens this section of the User’s Guide.

Resolved Addresses
The Resolved Addresses window shows the list of resolved addresses and their host names. Users
can choose the Hosts field to display IPv4 and IPv6 addresses only. In this case, the dialog displays
host names for each IP address in a capture file with a known host. This host is typically taken from
DNS answers in a capture file. In case of an unknown host name, users can populate it based on a
reverse DNS lookup. To do so, follow these steps:
1. Enable Resolve Network Addresses in the View › Name Resolution menu as this option is
disabled by default.
164

2. Select Use an external network name resolver in the Preferences › Name Resolution menu.
This option is enabled by default.
NOTE

The resolved addresses are not updated automatically after a user changes the
settings. To display newly available names, the user has to reopen the dialog.

The Ports tab shows the list of service names, ports and types.
Wireshark reads the entries for port mappings from the hosts service configuration files. See
Configuration Files section for more information.

check the screen below

Figure 77. Resolved Addresses window

The “Protocol Hierarchy” Window
The protocol hierarchy of the captured packets.

check the screen below
Figure 78. The “Protocol Hierarchy” Window

This is a tree of all the protocols in the capture. Each row contains the statistical values of one
protocol. Two of the columns (Percent Packets and Percent Bytes) serve double duty as bar graphs. If
a display filter is set it will be shown at the bottom.
The [ Copy ] button will let you copy the window contents as CSV or YAML.
Protocol hierarchy columns

Protocol
This protocol’s name.
Percent Packets
The percentage of protocol packets relative to all packets in the capture.
Packets
The total number of packets that contain this protocol.
Percent Bytes
The percentage of protocol bytes relative to the total bytes in the capture.
Bytes
The total number of bytes of this protocol.
Bits/s
The bandwidth of this protocol relative to the capture time.
End Packets
The absolute number of packets of this protocol where it was the highest protocol in the stack
(last dissected).

166

End Bytes
The absolute number of bytes of this protocol where it was the highest protocol in the stack (last
dissected).
End Bits/s
The bandwidth of this protocol relative to the capture time where was the highest protocol in
the stack (last dissected).
PDUs
The total number of PDUs of this protocol.
Packets usually contain multiple protocols. As a result, more than one protocol will be counted for
each packet. Example: In the screenshot 100% of packets are IP and 99.3% are TCP (which is
together much more than 100%).
Protocol layers can consist of packets that won’t contain any higher layer protocol, so the sum of all
higher layer packets may not sum to the protocol’s packet count. This can be caused by segments
and fragments reassembled in other frames, TCP protocol overhead, and other undissected data.
Example: In the screenshot 99.3% of the packets are TCP but the sum of the subprotocols (TLS,
HTTP, Git, etc.) is much less.
A single packet can contain the same protocol more than once. In this case, the entry in the PDUs
column will be greater than that of Packets. Example: In the screenshot there are many more TLS
and Git PDUs than there are packets.

Conversations
A network conversation is the traffic between two specific endpoints. For example, an IP
conversation is all the traffic between two IP addresses. The description of the known endpoint
types can be found in Endpoints.

The “Conversations” Window
The conversations window is similar to the endpoint Window. See The “Endpoints” Window for a
description of their common features. Along with addresses, packet counters, and byte counters the
conversation window adds four columns: the start time of the conversation (“Rel Start”) or (“Abs
Start”), the duration of the conversation in seconds, and the average bits (not bytes) per second in
each direction. A timeline graph is also drawn across the “Rel Start” / “Abs Start” and “Duration”
columns.

check the screen below

Figure 79. The “Conversations” window

Each row in the list shows the statistical values for exactly one conversation.
Name resolution will be done if selected in the window and if it is active for the specific protocol
layer (MAC layer for the selected Ethernet endpoints page). Limit to display filter will only show
conversations matching the current display filter. Absolute start time switches the start time
column between relative (“Rel Start”) and absolute (“Abs Start”) times. Relative start times match
the “Seconds Since First Captured Packet” time display format in the packet list and absolute start
times match the “Time of Day” display format.
If a display filter had been applied before the dialog is opened, Limit to display filter will be set
automatically. Additionally, after a display filter had been applied, two columns ("Total Packets")
and ("Percent Filtered") show the number of unfiltered total packets and the percentage of packets
in this filter display.
The [ Copy ] button will copy the list values to the clipboard in CSV (Comma Separated Values),
YAML format or JSON format. The numbers are generally exported without special formatting, but
this can be enabled if needed.
The [ Follow Stream… ] button will show the stream contents as described in The “Follow TCP
Stream” dialog box dialog. The [ Graph… ] button will show a graph as described in The “I/O
Graphs” Window.
[ Conversation Types ] lets you choose which traffic type tabs are shown. See Endpoints for a list of
endpoint types. The enabled types are saved in your profile settings.
TIP

168

This window will be updated frequently so it will be useful even if you open it before
(or while) you are doing a live capture.

Endpoints
A network endpoint is the logical endpoint of separate protocol traffic of a specific protocol layer.
The endpoint statistics of Wireshark will take the following endpoints into account:
TIP

If you are looking for a feature other network tools call a hostlist, here is the right
place to look. The list of Ethernet or IP endpoints is usually what you’re looking for.

Endpoint and Conversation types

Bluetooth
A MAC-48 address similar to Ethernet.
Ethernet
Identical to the Ethernet device’s MAC-48 identifier.
Fibre Channel
A MAC-48 address similar to Ethernet.
IEEE 802.11
A MAC-48 address similar to Ethernet.
FDDI
Identical to the FDDI MAC-48 address.
IPv4
Identical to the 32-bit IPv4 address.
IPv6
Identical to the 128-bit IPv6 address.
IPX
A concatenation of a 32-bit network number and 48-bit node address, by default the Ethernet
interface’s MAC-48 address.
JXTA
A 160-bit SHA-1 URN.
NCP
Similar to IPX.
RSVP
A combination of various RSVP session attributes and IPv4 addresses.

169

SCTP
A combination of the host IP addresses (plural) and the SCTP port used. So different SCTP ports
on the same IP address are different SCTP endpoints, but the same SCTP port on different IP
addresses of the same host are still the same endpoint.
TCP
A combination of the IP address and the TCP port used. Different TCP ports on the same IP
address are different TCP endpoints.
Token Ring
Identical to the Token Ring MAC-48 address.
UDP
A combination of the IP address and the UDP port used, so different UDP ports on the same IP
address are different UDP endpoints.
USB
Identical to the 7-bit USB address.
Broadcast and multicast endpoints

NOTE

Broadcast and multicast traffic will be shown separately as additional endpoints. Of
course, as these aren’t physical endpoints the real traffic will be received by some
or all of the listed unicast endpoints.

The “Endpoints” Window
This window shows statistics about the endpoints captured.

check the screen below

Figure 80. The “Endpoints” window

For each supported protocol, a tab is shown in this window. Each tab label shows the number of
endpoints captured (e.g., the tab label “Ethernet · 4” tells you that four ethernet endpoints have
been captured). If no endpoints of a specific protocol were captured, the tab label will be greyed out
(although the related page can still be selected).
Each row in the list shows the statistical values for exactly one endpoint.
Name resolution will be done if selected in the window and if it is active for the specific protocol
layer (MAC layer for the selected Ethernet endpoints page). Limit to display filter will only show
conversations matching the current display filter. Note that in this example we have MaxMind DB
configured which gives us extra geographic columns. See MaxMind Database Paths for more
information.
If a display filter had been applied before the dialog is opened, Limit to display filter will be set
automatically. Additionally, after a display filter had been applied, two columns ("Total Packets")
and ("Percent Filtered") show the number of unfiltered total packets and the percentage of packets
in this filter display.
The [ Copy ] button will copy the list values to the clipboard in CSV (Comma Separated Values),
YAML format or JSON format. The numbers are generally exported without special formatting, but
this can be enabled if needed. The [ Map ] button will show the endpoints mapped in your web
browser.
[ Endpoint Types ] lets you choose which traffic type tabs are shown. See Endpoints above for a list
of endpoint types. The enabled types are saved in your profile settings.
TIP

This window will be updated frequently, so it will be useful even if you open it before
(or while) you are doing a live capture.

Packet Lengths
Shows the distribution of packet lengths and related information.
check the screen below

Figure 81. The “Packet Lengths” window
Information is broken down by packet length ranges as shown above.
Packet Lengths
The range of packet lengths.
Ranges can be configured in the “Statistics → Stats Tree” section of the Preferences Dialog.
Count
The number of packets that fall into this range.
Average
The arithmetic mean of the packet lengths in this range.
Min Val, Max Val
The minimum and maximum lengths in this range.
Rate (ms)
The average packets per millisecond for the packets in this range.
Percent
The percentage of packets in this range, by count.
Burst Rate
Packet bursts are detected by counting the number of packets in a given time interval and
comparing that count to the intervals across a window of time. Statistics for the interval with the
maximum number of packets are shown. By default, bursts are detected across 5 millisecond
intervals and intervals are compared across 100 millisecond windows.
These calculations can be adjusted in the “Statistics” section of the Preferences Dialog.
Burst Start
The start time, in seconds from the beginning of the capture, for the interval with the maximum
number of packets.
You can show statistics for a portion of the capture by entering a display filter into the Display filter
entry and pressing [ Apply ].
[ Copy ] copies the statistics to the clipboard. [ Save as… ] lets you save the data as text, CSV, YAML,
or XML.

The “I/O Graphs” Window
Lets you plot packet and protocol data in a variety of ways.

check the screen below
Figure 82. The “I/O Graphs” window

As shown above, this window contains a chart drawing area along with a customizable list of
graphs. Graphs are saved in your current profile. They are divided into time intervals, which can be
set as described below. Hovering over the graph shows the last packet in each interval except as
noted below. Clicking on the graph takes you to the associated packet in the packet list. Individual
graphs can be configured using the following options:
Enabled
Draw or don’t draw this graph.
Graph Name
The name of this graph.
Display Filter
Limits the graph to packets that match this filter.
Color
The color to use for plotting the graph’s lines, bars, or points.
Style
How to visually represent the graph’s data, e.g., by drawing a line, bar, circle, plus, etc.

173

Y Axis
The value to use for the graph’s Y axis. Can be one of:
Packets, Bytes, or Bits
The total number of packets, packet bytes, or packet bits that match the graph’s display filter
per interval. Zero values are omitted in some cases.
SUM(Y Field)
The sum of the values of the field specified in “Y Field” per interval.
COUNT FRAMES(Y Field)
The number of frames that contain the field specified in “Y Field” per interval. Unlike the
plain “Packets” graph, this always displays zero values.
COUNT FIELDS(Y Field)
The number of instances of the field specified in “Y Field” per interval. Some fields, such as
dns.resp.name, can show up multiple times in a packet.
MAX(Y Field), MIN(Y Field), AVG(Y Field)
The maximum, minimum, and arithmetic mean values of the specified “Y Field” per interval.
For MAX and MIN values, hovering and clicking the graph will show and take you to the
packet with the MAX or MIN value in the interval instead of the most recent packet.
LOAD(Y Field)
If the “Y Field” is a relative time value, this is the sum of the “Y Field” values divided by the
interval time. This can be useful for tracking response times.
Y Field
The display filter field from which to extract values for the Y axis calculations listed above.
SMA Period
Show an average of values over a specified period of intervals.
The chart as a whole can be configured using the controls under the graph list:
[+]
Add a new graph.
[-]
Add a new graph.
[ Copy ]
Copy the selected graph.

174

[ Clear ]
Remove all graphs.
Mouse drags / zooms
When using the mouse inside the graph area, either drag the graph contents or select a zoom
area.
Interval
Set the interval period for the graph.
Time of day
Switch between showing the absolute time of day or the time relative from the start of capture
in the X axis.
Log scale
Switch between a logarithmic or linear Y axis.
Automatic updates
Redraw each graph automatically.
Enable legend
Show a legend for graphs with more than one type of Y axis.
The main dialog buttons along the bottom let you do the following:
The [ Help ] button will take you to this section of the User’s Guide.
The [ Copy ] button will copy values from selected graphs to the clipboard in CSV (Comma
Separated Values) format.
[ Copy from ] will let you copy graphs from another profile.
[ Close ] will close this dialog.
[ Save As… ] will save the currently displayed graph as an image or CSV data.
TIP

You can see a list of useful keyboard shortcuts by right-clicking on the graph.

Missing Values Are Zero
Wireshark’s I/O Graph window doesn’t distinguish between missing and zero values. For scatter
plots it is assumed that zero values indicate missing data, and those values are omitted. Zero values
are shown in line graphs, and bar charts.

175

Service Response Time
The service response time is the time between a request and the corresponding response. This
information is available for many protocols, including the following:
• AFP
• CAMEL
• DCE-RPC
• Diameter
• Fibre Channel
• GTP
• H.225 RAS
• LDAP
• MEGACO
• MGCP
• NCP
• ONC-RPC
• RADIUS
• SCSI
• SMB
• SMB2
• SNMP
As an example, the SMB2 service response time is described below in more detail. The other Service
Response Time windows will show statistics specific to their respective protocols, but will offer the
same menu options.

The “SMB2 Service Response Time Statistics” Window
This window shows the number of transactions for each SMB2 opcode present in the capture file
along with various response time statistics. Right-clicking on a row will let you apply or prepare
filters for, search for, or colorize a specific opcode. You can also copy all of the response time
information or save it in a variety of formats.

check the screen below
Figure 83. The “SMB2 Service Response Time Statistics” window

You can optionally apply a display filter in order to limit the statistics to a specific set of packets.
The main dialog buttons along the bottom let you do the following:
The [ Copy ] button will copy the response time information as text.
[ Save As… ] will save the response time information in various formats.
[ Close ] will close this dialog.

DHCP (BOOTP) Statistics
The Dynamic Host Configuration Protocol (DHCP) is an option of the Bootstrap Protocol (BOOTP). It
dynamically assigns IP addresses and other parameters to a DHCP client. The DHCP (BOOTP)
Statistics window displays a table over the number of occurrences of a DHCP message type. The
user can filter, copy or save the data into a file.

NetPerfMeter Statistics
The NetPerfMeter Protocol (NPMP) is the control and data transfer protocol of NetPerfMeter, the
transport protocol performance testing tool. It transmits data streams over TCP, SCTP, UDP and
DCCP with given parameters, such as frame rate, frame size, saturated flows, etc.
With these statistics you can:

177

• Observed number of messages and bytes per message type.
• The share of messages and bytes for each message type.
• See the first and last occurrence of each message type.
• See the interval between first and last occurrence of each message type (if there are at least 2
messages of the corresponding type).
• See the message and byte rate within the interval for each message type (if there are at least 2
messages of the corresponding type).
See NetPerfMeter – A TCP/MPTCP/UDP/SCTP/DCCP Network Performance Meter Tool and Section 6.3
of Evaluation and Optimisation of Multi-Path Transport using the Stream Control Transmission
Protocol for more details about NetPerfMeter and the NetPerfMeter Protocol.
check the screen below

Figure 84. NetPerfMeter Statistics window

ONC-RPC Programs
Open Network Computing (ONC) Remote Procedure Call (RPC) uses TCP or UDP protocols to map a
program number to a specific port on a remote machine and call a required service at that port.
The ONC-RPC Programs window shows the description for captured program calls, such as program
name, its number, version, and other data.

29West
The 29West technology now refers to Ultra-Low Latency Messaging (ULLM) technology. It allow
apps-fileview.texmex_20230622.01_p0
wireshark.txt
Displaying wireshark.txt.

[1]How to Sniff Traffic with Wireshark
Launch Wireshark, and start by sniffing some data. For that, you can hit Ctrl+K (PC) or Cmd+K (Mac)  to get the Capture Options window. Notice that you can reach this window in other ways. You can go to Capture->Options. Alternatively, you can click the Capture Options icon.
I encourage you to use keyboard shortcuts and get comfortable with them right from the start, as they'll allow you to save time and work more efficiently.
So, again, I’ve used Ctrl+K (or Cmd+K) and got this screen:
[New_Figure 1 : The Capture Options window in Wireshark

Here we can see a list of interfaces, and I happen to have quite a few. Which one is relevant? If you’re not sure at this point, you can look at the Traffic column, and see which interfaces currently have traffic.
Here we can see that Wi-Fi 3 has got traffic going through it, as the line is high. Select the relevant network interface, and then hit Enter, or click the button Start.
Let Wireshark sniff the network for a bit, and then stop the sniff using Ctrl+E / Cmd+E. Again, this can be achieved in other ways – such as going to Capture->Stop or clicking the Stop icon.
Consider the different sections in the given screen
New_Figure 2 : Wireshark's sections 

The section marked in red includes Wireshark’s menu, with all kinds of interesting options.
The main toolbar is marked in blue, providing quick access to some items from the menu.
Next, marked in green, is the display filter. We will get back to it shortly, as this is one of the most important features of Wireshark.
Then follows:
The Packet List Pane
The packet list pane is marked in orange. It displays a short summary of each packet captured.
(Note: the term Frame belongs to a sequence of bytes in the Data Link layer, while a Packet is a sequence of bytes from the Network layer. In this post I will use the terms interchangeably, though to be accurate, every packet is a frame, but not every frame is a packet, as there are frames that don't hold network layer data.)
As you can see in the image above, we have a few columns here:
NUMBER (No.) – The number of the packet in the capture file. This number won’t change, even if we use filters. This is just a sequential number – the first frame that you have sniffed gets the number 1, the second frame gets the number 2, and so on.
Time – The timestamp of the packet. It shows how much time has passed from the very first packet we have sniffed until we sniffed the packet in question. Therefore, the time for packet number 1 is always 0.
Source – The address where this packet is coming from. Don’t worry if you don’t understand the format of the addresses just yet, we will cover different addresses in future tutorials.
Destination – The address where this packet is going.
Protocol – The protocol name in a short version. This will be the top protocol – that is, the protocol of the highest layer.
Length – The length of each packet, in bytes.
Info – Additional information about the packet content. This changes according to the protocol.
By clicking on packets in this pane, you control what is displayed in the other two panes which I will now describe.
The Packet Details Pane
Click on one of the captured packets. In the example below I clicked on packet number 
In the below screenshot
147:
New_Figure 3 : Selecting a specific packet changes the packet details pane 

Now, the packet details pane displays the packet selected in the packet list pane in more detail. You can see the layers here.
In the example above, we have Ethernet II as the second layer, IPv4 as the third layer, UDP as the fourth layer, and some data as a payload.
When we click on a specific layer, we actually see the header of that layer.
Notice that we don’t see the first layer on its own. As a reminder, the first layer is responsible for transmitting a single bit – 0 or 1 – over the network 
Check the screen below
New_Figure 4 : The packet bytes pane in Wireshark

Below the packet details pane, we have the packet bytes pane. It displays the data from the packet selected in the packet list pane. This is the actual data being sent over the wire. We can see the data in hexadecimal base, as well as ASCII form.
How to Use the Display Filter
Wireshark has many different functions, and today we will focus on one thing – the display filter.
As you can see, once you start sniffing data, you get a LOT of traffic. But you definitely don’t want to look at everything.
Recall the example from before – using Wireshark in order to debug a chat program that you’ve implemented. In that case, you would like to see the traffic related to the chat program only.
Let’s say I want to filter only messages sent by the source address of frame number 149 ( 192.168.1.3 ). I will cover IP addresses in future posts, but for now you can see that it consists four numbers, delimited by a dot:
Check the screen below



New_Figure 5 : The display filter in Wireshark

Now, even if you don’t know how to filter only packets sent from this IP address, you can use Wireshark to show you how it’s done.
For that, go to the right field we would like to filter – in this case, the source IP address. Then right click -> and choose filter -> Apply as Filter.

Check the screen below

New_Figure 6 : Applying a display filter 

After applying the filter, you only see packets that have been sent from this address. Also, you can look at the display filter line and see the command used. In this way, you can learn about the display filter syntax (in this example, it is ip.src for the IP source address field):

Check the screen below
New_Figure 7 : Applying a display filter

Now, try to filter only packets that have been sent from this address, and to the address 172.217.16.142 (as in Frame 130 in the image above). How would you do that?
Well, you could go to the relevant field – in this case, the IP destination address. Now, right click -> Apply as Filter -> and select ...and Selected:

Check the screen below
New_Figure 8 : Applying a display filter

If you look at the display filter line after applying this filter:
Check the screen below
New_Figure 9 : Applying a display filter

You can also learn that you can use the && operand in order to perform and. You could also write the word and, instead, and get the same result.
Check the screen below
New_Figure 10 : Applying multiple conditions using && or and 
How to Use Wireshark to Research the Ping Utility
Ping is a useful utility to check for remote servers’ connectivity.
This page explains how to use ping in Windows, and this page explains how to do that in OSX.
Now, we can try to ping <address> using the command line. By default, ping sends 4 requests and waits for a pong answer. If we want it to send a single request, we could use -n 1:
Check the screen below
New_Figure 11 : Using the command line to ping Google 

You can see that Google has responded. The time it took for the message to return was 92 milliseconds. We will learn about the meaning of TTL in future posts.
Ping is useful to determine whether a remote service is available, and how fast it is to reach that service. If it takes a very long time to reach a reliable server such as google.com, we might have a connectivity problem.
















[2] Wireshark Tutorial: Decrypting HTTPS Traffic
This Wireshark tutorial describes how to decrypt HTTPS traffic from a pcap in Wireshark. Decryption is possible with a text-based log containing encryption key data captured when the pcap was originally recorded. With this key log file, we can decrypt HTTPS activity in a pcap and review its contents.
HTTPS Web Traffic
HTTPS traffic often reveals a domain name. For example, when viewing https://www.wireshark.org in a web browser, a pcap would show www.wireshark.org as the server name for this traffic when viewed in a customized Wireshark column display. Unfortunately, we don’t know other details like the actual URL or data returned from the server. Following the Transmission Control Protocol (TCP) stream from a pcap will not reveal the content of this traffic because it is encrypted.
Check the screen below
New_Figure 12 :Traffic from HTTPS traffic to www.wireshark.org.
Check the screen below
New_Figure 13 : TCP stream of HTTPS traffic to and from server at www.wireshark.org.
Encryption Key Log File
An encryption key log is a text file.Check the screen below
New_Figure 14 : The key log file used in this tutorial.
These logs are created using a Man in the Middle (MitM) technique when the pcap is originally recorded. If no such file was created when the pcap was recorded, you cannot decrypt HTTPS traffic in that pcap.
Example of a Pcap With a Key Log File
A password-protected ZIP archive containing the pcap and its key log file is available at this Github repository. Go to the Github page, click on the ZIP archive entry, then download it as shown in Figures 4 and 5. Of note, the pcap contained in this ZIP archive provides access to a Windows-based malware sample when decrypted with the key log. As always, we recommend you exercise caution and follow steps from this tutorial in a non-Windows environment.
Check the screen below
New_Figure 15 : Github repository with link to ZIP archive used for this tutorial.
Check the screen belowNew_Figure 16 :Downloading the ZIP archive for this tutorial.
Use infected as the password to extract the pcap and key log file from the ZIP archive. This will provide two files as shown in Figure 6:
Wireshark-tutorial-KeysLogFile.txt
Wireshark-tutorial-on-decrypting-HTTPS-SSL-TLS-traffic.pcap
Check the screen below
New_Figure 17 :Key log file and pcap for this tutorial.
HTTPS Traffic Without the Key Log File
Open Wireshark-tutorial-on-decrypting-HTTPS-SSL-TLS-traffic.pcap in Wireshark. Use a basic web filter as described in this previous tutorial about Wireshark filters. Our basic filter for Wireshark 3.x is:
(http.request or tls.handshake.type eq 1) and !(ssdp)
This pcap is from a Dridex malware infection on a Windows 10 host. All web traffic, including the infection activity, is HTTPS. Without the key log file, we cannot see any details of the traffic, just the IP addresses, TCP ports and domain names, as shown in the screen belowNew_Figure 18 : Viewing the pcap in Wireshark using the basic web filter without any decryption.
Loading the Key Log File
Open Wireshark-tutorial-on-decrypting-HTTPS-SSL-TLS-traffic.pcap in Wireshark. Then use the menu path Edit --> Preferences to bring up the Preferences Menu, as shown in screen below
.
New_Figure 19 :Getting to the Preferences Menu in Wireshark.
On the left side of the Preferences Menu, click on Protocols, as shown in screen belowNew_Figure 20 : Selecting Protocols in the Preferences Menu.
If you are using Wireshark version 2.x, scroll down until you find SSL and select it. If you are using Wireshark version 3.x, scroll down to TLS and select it. Once you have selected SSL or TLS, you should see a line for (Pre)-Master-Secret log filename. Click on the “Browse” button and select our key log file named Wireshark-tutorial-KeysLogFile.txt, as shown in screen belowNew_Figure 21 :Finding the (Pre)-Master-Secret log filename field under TLS in Wireshark 3.x.
New_Figure 22 :Selecting our key log file for this tutorial.New_Figure 23 : Once the file has been selected as the (Pre)-Master-Secret log filename, click “OK.”
HTTPS Traffic With the Key Log File
Once you have clicked “OK,” when using the basic filter, your Wireshark column display will list the decrypted HTTP requests under each of the HTTPS lines, as shown in 
Screen belowNew_Figure 24 :HTTPS decryption in Wireshark after using the key log file.
In this pcap, we now see HTTP requests to microsoft.com and skype.com domains previously hidden in the HTTPS traffic. We also find the following traffic caused by the Dridex infection:
foodsgoodforliver[.]com - GET /invest_20.dll
105711[.]com - POST /docs.php
The GET request to foodsgoodforliver[.]com returned a DLL file for Dridex. The POST requests to 105711[.]com are command and control (C2) traffic from the Dridex-infected Windows host.
We can review the traffic by following HTTP streams. Right-click on the line to select it, then left-click to bring up a menu to follow the HTTP stream. Figures 14 and 15 show following the HTTP stream for the HTTP GET request to foodsgoodforliver[.]com.
Check the screen below
New_Figure 25 : Following HTTP stream for the GET request to foodsgoodforliver[.]com.New_Figure 26 : HTTP stream indicates an EXE or DLL returned from the server.
Since we have the key log file for this traffic, we can now export this malware from the pcap. Use the menu path File --> Export Objects --> HTTP to export this file from the pcap, as shown in screen below
New_Figure 27 : Exporting the malware binary returned from foodsgoodforliver[.]com.If you are in a BSD, Linux or macOS environment, open a terminal window and use the file command to confirm this is a DLL file. Then use shasum -a 256 to get the SHA256 hash of the file.


Check the screen below
New_Figure 28 : Getting the SHA256 hash of this malware in a Linux environment.
The SHA256 hash of this malware is:
31cf42b2a7c5c558f44cfc67684cc344c17d4946d3a1e0b2cecb8eb58173cb2f
If you search for this hash online, you should find results from at least two publicly available online sandbox environments.
Finally, we can review C2 traffic from this Dridex infection. Use your basic web filter, then follow an HTTP stream from one of the POST requests to 105711[.]com. An example from one of the HTTP streams is shown in screen below
New_Figure 29: HTTP stream from one of the Dridex C2 POST requests.
Conclusion
This tutorial reviewed how to decrypt HTTPS traffic in a pcap with Wireshark using a key log text file. Without a key log file created when the pcap was originally recorded, you cannot decrypt HTTPS traffic from that pcap in Wireshark.






[3]Using statistical tools in Wireshark for packet analysis
Using the statistics for capture file properties menu
In this recipe, we will learn how to get general information from the data that runs over the network. The capture file properties in Wireshark 2 replaces the summary menu in Wireshark 1.
Start Wireshark, click on Statistics.
How to do it:
From the Statistics menu, choose Capture File Properties: 
Check the screen below

New_Figure 30: Capture File Properties window 
As you can see in the following screenshot, we have the following:
File: Provides file data, such as filename and path, length, and so on
Time: Start time, end time, and duration of capture
Capture: Hardware information for the PC that Wireshark is installed on
Interfaces: Interface information—the interface registry identifier on the left, if capture filter is turned on, interface type and packet size limit
Statistics: General capture statistics, including captured and displayed packets:
Check the screen below

New_Figure 31: diagram31
How it works:
This menu simply gives a summary of the filtered data properties and the capture statistics (average packets or bytes per second) when someone wants to learn the capture statistics.
Using the statistics for protocol hierarchy menu
In this recipe, we will learn how to get protocol hierarchy information of the data that runs over the network.
Start Wireshark, click on Statistics.
How to do it…
From the Statistics menu, choose Protocol Hierarchy:Check the screen below

New_Figure 32: What you will get is data about the protocol distribution in the captured file. You will get the protocol distribution of the captured data.
The partial screenshot displayed here depicts the statistics of packets captured on a per-protocol basis:.Check the screen below

New_Figure 33: What you will get is the Protocol Hierarchy window:
Protocol: The protocol name
Percent Packets: The percentage of protocol packets from the total captured packets
Packets: The number of protocol packets from the total captured packets
Percent Bytes: The percentage of protocol bytes from the total captured packets
Bytes: The number of protocol bytes from the total captured packets
Bit/s: The bandwidth of this protocol, in relation to the capture time
End Packets: The absolute number of packets of this protocol (for the highest protocol in the decode file)
End Bytes: The absolute number of bytes of this protocol (for the highest protocol in the decode file)
End Bit/s: The bandwidth of this protocol, relative to the capture packets and time (for the highest protocol in the decode file)
The end columns counts when the protocol is the last protocol in the packet (that is, when the protocol comes at the end of the frame). These can be TCP packets with no payload (for example, SYN packets) which carry upper layer protocols. That is why you see a zero count for Ethernet, IPv4, and UDP end packets; there are no frames where those protocols are the last protocol in the frame.
In this file example, we can see two interesting issues:
We can see 1,842 packets of DHCPv6. If IPv6 and DHCPv6 are not required, disable it.
We see more than 200,000 checkpoint high availability (CPHA) packets, 74.7% of which are sent over the network we monitored. These are synchronization packets that are sent between two firewalls working in a cluster, updating session tables between the firewalls. Such an amount of packets can severely influence performance. The solution for this problem is to configure a dedicated link between the firewalls so that session tables will not influence the network.
How it works…
Simply, it calculates statistics over the captured data. Some important things to notice:
The percentage always refers to the same layer protocols. For example, in the following screenshot, we see that logical link control has 0.5% of the packets that run over Ethernet, IPv6 has 1.0%, IPv4 has 88.8% of the packets, ARP has 9.6% of the packets and even the old Cisco ISK has 0.1 %—a total of 100 % of the protocols over layer 2 Ethernet.
On the other hand, we see that TCP has 75.70% of the data, and inside TCP, only 12.74% of the packets are HTTP, and that is almost it. This is because Wireshark counts only the packets with the HTTP headers. It doesn’t count, for example, the ACK packets, data packets, and so on:Check the screen below
New_Figure 34: Using the statistics for conversations menu


In this recipe, we will learn how to get conversation information of the data that runs over the network.
Start Wireshark, click on Statistics.
How to do it…
From the Statistics menu, choose Conversations:Check the screen below

New_Figure 35: diagram35






The following window will come up:Check the screen below

New_Figure 36: You can choose between layer 2 Ethernet statistics, layer 3 IP statistics, or layer 4 TCP or UDP statistics.
You can use this statistics tools for:
On layer 2 (Ethernet): To find and isolate broadcast storms
On layer 3/layer 4 (TCP/IP): To connect in parallel to the internet router port, and check who is loading the line to the ISP
If you see that there is a lot of traffic going out to port 80 (HTTP) on a specific IP address on the internet, you just have to copy the address to your browser and find the website that is most popular with your users.
If you don’t get anything, simply go to a standard DNS resolution website (search Google for DNS lookup) and find out what is loading your internet line.
For viewing IP addresses as names, you can check the Name resolution checkbox for name resolution (1 in the previous screenshot). For seeing the name resolution, you will first have to enable it by choosing View | Name Resolution | Enable for Network layer.
You can also limit the conversations statistics to a display filter by checking the Limit to display filter checkbox (2). In this way, statistics will be presented on all the packets passing the display filter.
A new feature in Wireshark version 2 is the graph feature, marked as (5) in the previous screenshot. When you choose a specific line in the TCP conversations statistics and click Graph…, it brings you to the TCP time/sequence (tcptrace) stream graph.
To copy table data, click on the Copy button (3). In TCP or UDP, you can mark a specific line, and then click on the Follow Stream… button (4). This will define a display filter that will show you the specific stream of data. As you can see in the following screenshot, you can also right-click a line and choose to prepare or apply a filter, or to colorize a data stream:Check the screen below

New_Figure 37: We also see that, unlike the previous Wireshark version, in which we saw all types of protocols in the upper tabs, here we can choose which protocols to see when only the identified protocols are presented by default.
How it works…
A network conversation is the traffic between two specific endpoints. For example, an IP conversation is all the traffic between two IP addresses, and TCP conversations present all TCP connections.
Using the statistics for endpoints menu
In this recipe, we will learn how to get endpoint statistics information of the captured data.
Start Wireshark and click on Statistics.
How to do it…
To view the endpoint statistics, follow these steps:
From the Statistics menu, choose Endpoints:Check the screen below

New_Figure 38: diagram38
The following window will come up:Check the screen below

New_Figure 39: diagram39


In this window, you will be able to see layer 2, 3, and 4 endpoints, which is Ethernet, IP, and TCP or UDP.
From the left-hand side of the window you can see (here is an example for the TCP tab):
Endpoint IP address and port number on this host
Total packets sent, and bytes received from and to this host
Packets to the host (Packets A → B) and bytes to host (Bytes A → B)
Packets to the host (Packets B → A) and bytes to host (Bytes B → A)
The Latitude and Longitude columns applicable with the GeoIP configured
At the bottom of the window we have the following checkboxes:
Name resolution: Provide name resolution in cases where it is configured in the name resolution under the view menu.
Limit to display filter: To show statistics only for the display filter configured on the main window.
Copy: Copy the list values to the clipboard in CSV or YAML format.
Map: In cases where GeoIP is configured, shows the geographic information on the geographical map.
How it works…
Quite simply, it gives statistics on all the endpoints Wireshark has discovered. It can be any situation, such as the following:
Few Ethernet (even on) end nodes (that is, MAC addresses), with many IP end nodes (that is, IP addresses)—this will be the case where, for example, we have a router that sends/receives packets from many remote devices.
Few IP end nodes with many TCP end nodes—this will be the case for many TCP connections per host. Can be a regular operation of a server with many connections, and it could also be a kind of attack that comes through the network (SYN attack).
We learned about Wireshark’s basic statistic tools and how you can leverage those for network analysis.
[4] Analyzing VoIP traffic using Wireshark
To access the VoIP calls analysis use the menu entry "Telephony->VoIP Calls…". The current VoIP supported protocols are:
SIP
H323
ISUP
MGCP
UNISTIM
with the corresponding RTP streams.
See VOIPProtocolFamily for an overview of the used VoIP protocols.
To try out this dialog, a small capture file containing a VoIP call can be found at SampleCaptures/rtp_example.raw.gz which contains an example H323 call including H225, H245, RTP and RTCP packets.
List VoIP calls
Check the screen below
New_Figure 40: diagram40
The VoIP calls list shows the following information per call:
Start Time: Start time of the call.
Stop Time: Stop time of the call.
Initial Speaker: The IP source of the packet that initiated the call.
From: For H323 and ISUP calls, this is the calling number. For SIP calls, it is the "From" field of the INVITE. For MGCP calls, the EndpointID or calling number. For UNISTIM the Terminal ID.
To: For H323 and ISUP calls, this is the called number. For SIP calls, it is the "To" field of the INVITE. For MGCP calls, the EndpointID or dialed number. For UNISTIM the dialed number.
Protocol: Any of the protocols listed above
Packets: Number of packets involved in the call.
State: The current call state. The possible values are
CALL SETUP: call in setup state (Setup, Proceeding, Progress or Alerting)
RINGING: call ringing (only supported for MGCP calls)
IN CALL: call is still connected
CANCELLED: call was released before connect from the originated caller
COMPLETED: call was connected and then released
REJECTED: call was released before connect by the destination side
UNKNOWN: call in unknown state
Comment: An additional comment, this is protocol dependent. For H323 calls it shows if the call uses Fast Start or/and H245 Tunneling.
Filtering a call
To prepare a filter for a particular call, just select the desired call and press "Prepare Filter" button. This will create a filter in the Main Wireshark windows to filter the packets related to this call. This is specially useful when you want to connect ISUP calls according to some CIC value.
VoIP calls Graph analysis
Check the screen below
New_Figure 41: diagram41
To Graph analysis one or multiple calls from the VoIP List, select them from the list and then press the "Graph" button.
The Graph will show the following information:
Up to Ten columns representing an IP address each one.
All packets that belong to the same call are colorized with the same color
An arrow showing the direction of each packet in the calls
The label on top of the arrow shows message type. When available, it also shows the media codec.
The RTP traffic is summarized in a wider arrow with the corresponded Codec.
Shows the UDP/TCP source and destination port per packet.
The comment column has protocol dependent information:
H323:
Fast Start and H245 Tunneling ON/OFF for the packet.
The SETUP message shows the calling and called number
The RELEASE message shows the Q.931 Release cause code
SIP:
Shows if the packet is a "Request" or a "Staus" message.
The INVITE message also shows the "From" and "To" fields
ISUP:
The format is as follows: NetworkID-Originating Point Code -> NetworkID-Destination Point Code, CIC
MGCP:
The MGCP Endpoint ID, and if the packet is a "Request" or "Response" message.
UNISTIM:
Details of the message, and the sequence #.
RTP:
Number of RTP packets in the stream, the duration in seconds and the SSRC field.
When clicking a packet in the Graph, the selected frame will be selected in the Main Wireshark window.
Playing VoIP calls
Wireshark allows you to play any codec supported by an installed plugin. Wireshark allows you to save decoded audio in .au file format. Prior to version 3.2.0, it only supported saving audio using the G.711 codec; from 3.2.0 it supports saving audio using any codec with 8000 Hz sampling.
The codecs supported by Wireshark depend on the version of Wireshark you're using. The official builds contain all of the plugins maintained by the Wireshark developers, but custom/distribution builds might not include some of those codecs. To check your Wireshark follow this procedure:
open Help -> About Wireshark window
switch to Plugins tab
select codec as Filter by type
Check the screen below

New_Figure 42: diagram42
To play the RTP audio stream of one or multiple calls from the VoIP List, select them from the list and then press the "Player" button:


Check the screen below

New_Figure 43: diagram43
Choose an initial value for the jitter buffer and then press the "Decode button". The jitter buffer emulated by Wireshark is a fixed size jitter buffer and can efficiently be used to reproduce what clients can effectively hear during the VoIP call.
You can now see all RTP streams available for the calls that you selected:
Check the screen below

New_Figure 44: diagram44
Note that all RTP packets that are dropped because of the jitter buffer are reported ("Drop by Jitter Buff"), as well as the packets that are out of sequence (Out of Seq).
Pressing the "Play" button plays the RTP stream from within Wireshark. A progress bar indicates the position in the stream and is synchronized amongst all RTP streams that are played.





































[5] Steps to perform Remote Packet Capture with Wireshark

Remote packet capture on a Windows operating system
Remote capturing on a Windows OS requires WinPcap tool installation. WinPcap consists of a driver that extends the operating system to provide low-level network access and a library that is used to easily access low-level network layers. This library also contains the Windows version of the well-known libpcap Unix API. Thanks to its set of features, WinPcap has been the packet capture and filtering engine for many open source and commercial network tools, including protocol analyzers, network monitors, network intrusion detection systems, sniffers, traffic generators and network testers. Some of these networking tools, like Wireshark, Nmap, Snort, and ntop are known and used throughout the networking community.
 
Step-1: WinPcap comes with the older Wireshark versions in default. If you do not have it, download it from here (https://www.winpcap.org/default.htm) and install it on the remote machine. After installation, it will create a "service", which is called "Remote Packet Capture Protocol v.0 (experimental)".
Step-2: The service created by WinPcap supports two authentication methods; null (anonymous) and user credential based authentication. I assume you already have a user account on the remote machine, if not, create a new user on it.
Step-3: Open "Start" menu and search for "Services", then click the top result to open the console. Find "Remote Packet Capture Protocol v.0 (experimental)" service from the right pane.Check the screen below

 
New_Figure 45: diagram45
Step-4: Double click on the service, the Properties window will open.
Step-5: Select "Log On" tab, then "This account" radio button. Enter your credentials and click on "Apply" button.Check the screen below

 New_Figure 46: diagram46
Step-6: Select "General" tab, and then click "Start" button to start the service. Click on the "OK" to finish. At this point, the service is up and running.Check the screen below

 New_Figure 47: diagram47
Step-7: I will start a continuous ping from the remote server (192.168.1.150) to another server (192.168.1.42) with the command below.  In the next step, we will capture ping packets (ICMP) from a remote host.
bash
C:\Users\Administrator>ping 192.168.1.42 -t
Pinging 192.168.1.42 with 32 bytes of data:
Reply from 192.168.1.42: bytes=32 time<1ms TTL=64
Reply from 192.168.1.42: bytes=32 time<1ms TTL=64
Reply from 192.168.1.42: bytes=32 time<1ms TTL=64
Reply from 192.168.1.42: bytes=32 time<1ms TTL=64
Reply from 192.168.1.42: bytes=32 time<1ms TTL=64
Reply from 192.168.1.42: bytes=32 time<1ms TTL=64
Step-7: There will be no further configuration on the remote host. Launch Wireshark on the local machine and navigate to Capture → Options.Check the screen below



 New_Figure 48: diagram48
Step-8: Instead of selecting a local interface from the list, click on "Manage Interfaces". A window containing "Local Interfaces", "Pipes" and "Remote Interfaces" tabs appears.
Check the screen below

 New_Figure 49: diagram49
Step-9: Open "Remote Interfaces" tab and click "+" button to add remote host information. The WinPcap service runs on the port number 2002. Fill the all fields and click "OK". Wireshark will connect to the remote host and pull the remote interfaces information.
Check the screen below

 New_Figure 50: diagram50
I have two interfaces on the remote host. My output is below.
Check the screen below
 New_Figure 51: diagram51


Click "OK" to finish adding the remote interfaces.
Step-9: Select one of the remote interfaces and click "Start" button to start remote capturing on the interface.
Check the screen below

 New_Figure 52: diagram52
Step-10: From this moment, you are seeing the packets on the remote host.
Check the screen below

 New_Figure 53: diagram53
 
 
Step-11:  Wireshark uses a protocol called Remote Packet Capture Protocol (RPCAP) to create a remote session. Before transferring the packets from the remote host to the local host, authentication mechanism kicks in and then the local host sends parameters like what interfaces and what filter to use.
Check the screen below

 New_Figure 54: diagram54
After establishing the session, the remote host creates a new TCP connection with different source and destination ports to transfer packets. Following Wireshark output shows the protocol stack.
Check the screen below

 New_Figure 55: diagram55
Remote packet capture on Linux (Kali)
Wireshark is not shipped with SSHdump tool that make you enable to capture packet on a remote Linux distro. I have Wireshark-win64-3.0.3 version and I will remove it and reinstall to demonstrate the capture.


Step-1: Start Wireshark installation/reinstallation process.
Step-2: Expand the "Tools" tree in the "Choose Components" window.
Check the screen below

 New_Figure 56: diagram56
Step-3: Select "SSHdump" from the tool list and click "Next".
Check the screen below

 New_Figure 57: diagram57
Step-4: Finish the installation.
Step-5: Launch Wireshark and you will see some new tools such as "Cisco remote capture" and "SSH remote capture".
Check the screen below

 New_Figure 58: diagram58
Step-6: Click "SSH remote capture" and following window opens. Select "Server" tab and type the remote server IP address and SSH port.
Check the screen below

 New_Figure 59: diagram59
Step-7: Select "Authentication" tab and enter the user credential. Since Wireshark runs "tcpdump -U -i 'eth0'  -w -  ''" command,  it requires  root privileges.
Check the screen below

 New_Figure 60: diagram60
Step-8: Select "Capture" tab and enter the remote interface. The form lets you enter the command to be run. You can use "sudo" on the remote machine when you are not root. Even remote capture filter can be specified here.
Check the screen below

 New_Figure 61: diagram61
Step-9: Select "Debug" tab and check "Run in debug mode", then name a file to store all the debug logs. When there is a problem, we can take a look at the log file to understand the problem. The file is located in Wireshark base directory.
Check the screen below

 New_Figure 62: diagram62
Step-10:  Click "Start" button to starting remote capture. Unfortunately, I got the error below which says my Wireshark does not support cipher suits remote host negotiating.
Check the screen below

 New_Figure 63: diagram63
You can see the same logs in the debug file as well. My output is below.
Check the screen below

 New_Figure 64: diagram64
Step-11:  There are two methods to fix this problem. First option is to modify the parameter on the remote host, while second option is to install a newer Wireshark version.  I will go with the second solution and install Wireshark-win64-3.6.2.
Step-12:  After installation, it worked without any trouble. I pinged the remote machine from another host. The output is below.
Check the screen below

 New_Figure 65: diagram65
Up to this point, we used two different platforms (Windows and Linux) to capture remote packets. I already explained how things go when remote machine is a Windows. It uses a different method to capture from Linux. First Wireshark uses SSHdump tool to connect the host. After that it makes the host run "tcpdump" tool with some parameters. Tcpdump listens the interface and captures the packets. Then, the packets are transferred through the SSH session.









[6] Network traffic analysis using Wireshark

Network traffic analysis is the routine task of various job roles, such as network administrator, network defenders, incident responders and others. Wireshark plays a vital role during the traffic analysis

Capture filters with protocol header values
Wireshark comes with several capture and display filters. But a user can create display filters using protocol header values as well. Use this technique to analyze traffic efficiently.
proto[offset:size(optional)]=value
Following the above syntax, it is easy to create a dynamic capture filter, where:
proto = desired protocol
offset = header value
size = data length
value = data you want to find
Check the screen below

 New_Figure 66:  resources.infosecinstitute.com
Some instances are in the following table:
Check the tables below

 New_Figure 67:  resources.infosecinstitute.com
Analyzing endpoints
This feature comes in handy to determine the endpoint generating the highest volume or abnormal traffic in the network. To analyze the endpoints between two communication devices, do the following:
Capture traffic and select the packet whose endpoint you wish to check. -> Click Statistics menu -> Select Endpoints.
The most traffic-intensive endpoint, as seen in the screen below, is 192.168.10.4.
 New_Figure 68: diagram68
ARP traffic analysis
Address resolution protocol (ARP) generally uses to find the MAC address of the target machine. In this demo, let's try capturing and analyzing ARP traffic.
First things first, know the target machine IP. In our case, it's going to be the default gateway address.
Check the screen below

New_Figure 69: diagram69
Find existing ARP cache -> Delete the existing one to understand the demo -> Check ARP cache for verification.
Check the screen below

New_Figure 70: diagram70
Start Wireshark data capturing, and ping the default gateway address -> Now, let's analyze what happens after removing the ARP entry and pinging a new IP address in the meantime.
Analyze an ARP Request
Using the 'arp' filter, analyze the captured traffic in Wireshark.
Observe the packet request details from Ethernet and ARP; observe the source and destination IP and sender MAC and IP address.
Monitor the victim's MAC address. Since the destination MAC address is unavailable at the request packet stage, the victim's MAC address is zero, and the destination IP is the local system IP address.
Check the screen below

New_Figure 71: diagram71
Analyze an ARP Response
Observe the packet replay details from Ethernet and ARP; observe the change in source and destination IP and MAC addresses.
The destination and source MAC address are switched in the response packet.
Everything is similar as before, except the target MAC address, which was all zeroes before. Now, that has turned into your MAC address.
Check the screen below

New_Figure 72: ICMP traffic analysis
ICMP is used for error alerting and monitoring to verify whether data arrives in a timely basis at its desired destination.
To capture ICMP traffic, ping Google.com. Use the ‘ICMP’ filter to see ICMP traffic. Click the ICMP echo-request packet from the Wireshark capture window and start observing the information.
In the request packet, the source IP is your (requestor) IP address. Whereas the destination IP is that of Google. You can also analyze the ICMP details like Checksum, Identifier Number,  Sequence Number, etc.
Check the screen below

New_Figure 73: diagram73
In the response packet, observe the swapping of IPs between source and destination. You can also compare both request and response details, as they are similar.
Check the screen below

New_Figure 74: HTTPS traffic analysis
The Hypertext Transfer Application Layer Protocol (HTTP) utilizes the internet to establish protocols whenever the HTTP client/server transmits/receives HTTP requests.
Start a Wireshark capture -> Open a web browser  -> Navigate to any HTTPS-based website -> Stop the Wireshark capture.
Input ' ssl' in the filter box to monitor only HTTPS traffic ->  Observe the first TLS packet -> The destination IP would be the target IP (server).
Check the screen below

New_Figure 75: diagram75
To see more traffic of the target IP (destination IP), input the following filter
ip.addr ==


Check the screen below

New_Figure 76: TCP traffic analysis
A standard port scan takes advantage of the TCP three-way handshake. The attacker sends the SYN packet to the target port. The port is considered open when he gets SYN+ACK as a response, whereas the arrival of RST shows the port is closed. After receiving SYN+ACK, the hacker would send an ACK packet to establish a TCP connection.
Let's analyze a TCP network traffic using telnet on Google port 80. Capture the Wireshark traffic while entering the telnet command.
Check the screen below

New_Figure 77: diagram77
Analyze TCP SYN traffic
Input ‘tcp.port == 80’ to see only TCP traffic connected to the webserver connection.
Observe the TCP [SYN] packet. Expand Ethernet and observe the destination address that is the default gateway address; whereas, the source is your own MAC address.
To check the IP details, observe Internet Protocol Version 4; in our case, the destination IP is Googles' web server IP, and the source IP is the local IP address.
To view TCP details, observe Transmission Control Protocol, like port numbers. Monitor the flag values. SYN, which is enabled, shows the initial section of the TCP three-way handshake.
Check the screen below

New_Figure 78: diagram78
Analyze TCP SYN, ACK traffic
Take a look at the TCP [SYN, ACK] packet. Expand Ethernet and observe the destination address now would be your own MAC address; whereas the source is the default gateway address.
Monitor the acknowledgement code. It's worth noting that the number is one relative ACK number. The real acknowledgement value is one higher than the previous segment's identifier.
Monitor the flag values. [SYN, ACK], which is enabled, shows the second section of the TCP three-way handshake.
Check the screen below

 New_Figure 79: diagram79
Analyze TCP ACK traffic
Now consider the TCP [ACK] packet. Expand Ethernet and observe the destination address that is the default gateway address; whereas the source is your own MAC address. To view TCP details like port numbers, expand Transmission Control Protocol.
The enable ACK flag signals that the TCP three-way handshake has reached the last phase. The client and server have started a TCP session.
Check the screen below
New_Figure 80: diagram80
Analyze SYN flood attack
SYN flood occurs when an attacker delivers a substantial amount of SYN packets to a server using fake IPs, causing the server to respond with an SYN+ACK and keep its ports partially open, expecting a response from an invisible client.
By overwhelming a victim with SYN packets, an attacker can effectively overrun the victim's resources. In this state, the victim fights with traffic, which causes processor and memory usage to rise, eventually exhausting the victim's resources.
Use the hping3 tool to flood the victim IP. Simultaneously, start capturing the traffic on Wireshark. Input 'tcp.flags.syn == 1' in the filter box to view SYN packets flood.
Check the screen below

New_Figure 81: diagram81
Notice a lot of SYN packets with no lag time.
Check the screen below

New_Figure 82: Analyze DoS attacks
Let’s simulate a Denial of Service (DoS) attack to analyze it via Wireshark. For the demo, I am using the macof tool, the component of the Dsniff suit toolkit, and flooding a surrounding device's switch with MAC addresses.
The image below shows IP address is generating requests to another device with the same data size repeatedly. This sort of traffic shows a standard network DoS attack.
Check the screen below

New_Figure 83: diagram83
For a DDoS attack, use the macof tool again to generate traffic. Observe the fake source and destination IP addresses are sending many packets with similar data sizes.
Check the screen below

New_Figure 84: diagram84
Conclusion
Wireshark is an essential tool that many blue team and network administrators use daily. The objective might differ, but they analyze network traffic using it. In this article, we have explored several network traffic types like HTTPS, TCP, etc. In addition, we have seen few attacks using Wireshark, like the DoS attack.

































[7] Remote Packet Capture - Cisco 
Remote Packet Capture
The Remote Packet Capture feature enables you to specify a remote port as the destination for packet captures. This feature works in conjunction with the Wireshark network analyzer tool for Windows. A packet capture server runs on the WAP device and sends the captured packets through a TCP connection to the Wireshark tool. Wireshark is an open source tool and is available for free; it can be downloaded from http://www.wireshark.org.
A Microsoft Windows computer running the Wireshark tool allows you to display, log, and analyze captured traffic. The remote packet capture facility is a standard feature of the Wireshark tool for Windows. Remote packet capture is not standard on the Linux version of Wireshark and the Linux version does not work with the WAP device.
When remote capture mode is in use, the WAP device does not store any captured data locally in its file system.
If a firewall is installed between the Wireshark computer and the WAP device, these ports must be allowed to pass through the firewall. The firewall must also be configured to allow the Wireshark computer to initiate TCP connection to the WAP device.
To initiate a remote capture on a WAP device:
Click Administration > Packet Capture.
Enable Promiscuous Capture.
Select the Remote radio button.
Use the default port (2002), or if you are using a port other than the default, enter the desired port number used for connecting Wireshark to the WAP device.
Click Save.
Click Start Capture.
To initiate the Wireshark network analyzer tool for Microsoft Windows:
On the same computer, initiate the Wireshark tool.
In the menu, select Capture > Options. A pop-up appears.
At Interface, select Remote. A pop-up appears.
At Host, enter the IP address of the WAP device.
At Port, enter the port number of the WAP. For example, enter 2002 if you used the default, or enter the port number if you used a port other than the default.
Click OK.
Depending on the interface from which you need to capture packets, select an interface for capture. At the Wireshark pop-up, next to the IP address, there is a pulldown list for you to select the interfaces. The interface can be one of the following:
Linux bridge interface in the wap device 
--rpcap://[192.168.1.220]:2002/brtrunk 
Wired LAN interface
-- rpcap://[192.168.1.220]:2002/eth0
VAP0 traffic on radio 1 
-- rpcap://[192.168.1.220]:2002/wlan0
802.11 traffic
-- rpcap://[192.168.1.220]:2002/radio1
At WAP321, VAP1 ~ VAP7 traffic
-- rpcap://[ 192.168.1.220]:2002/wlan0vap1 ~ wlan0vap7
At WAP121, VAP1 ~ VAP3 traffic
-- rpcap://[ 192.168.1.220]:2002/wlan0vap1 ~ wlan0vap3 

You can trace up to four interfaces on the WAP device at the same time. However, you must start a separate Wireshark session for each interface. To initiate additional remote capture sessions, repeat the Wireshark configuration steps; no configuration needs to be done on the WAP device.
NOTE     The system uses four consecutive port numbers, starting with the configured port for the remote packet capture sessions. Verify that you have four consecutive port numbers available. We recommend that if you do not use the default port, use a port after 1024.
When you are capturing traffic on the radio interface, you can disable beacon capture, but other 802.11 control frames are still sent to Wireshark. You can set up a display filter to show only:
Data frames in the trace
Traffic on specific BSSIDs
Traffic between two clients
Some examples of useful display filters are:
Exclude beacons and ACK/RTS/CTS frames:
!(wlan.fc.type_subtype == 8 | | wlan.fc.type == 1)Data frames only:
wlan.fc.type == 2Traffic on a specific BSSID:
wlan.bssid == 00:02:bc:00:17:d0All traffic to and from a specific client:
wlan.addr == 00:00:e8:4e:5f:8e
In remote capture mode, traffic is sent to the computer running Wireshark through one of the network interfaces. Depending on where the Wireshark tool is located, the traffic can be sent on an Ethernet interface or one of the radios. To avoid a traffic flood caused by tracing the trace packets, the WAP device automatically installs a capture filter to filter out all packets destined to the Wireshark application. For example if the Wireshark IP port is configured to be 58000 then the capture filter is automatically installed on the WAP device:
not portrange 58000-58004.
Enabling the packet capture feature impacts performance of the WAP device and can create a security issue (unauthorized clients may be able to connect to the WAP device and trace user data). The WAP device performance is negatively impacted even if there is no active Wireshark session with the WAP device. The performance is negatively impacted to a greater extent when packet capture is in progress.
Due to performance and security issues, the packet capture mode is not saved in NVRAM on the WAP device; if the WAP device resets, the capture mode is disabled and the you must reenable it in order to resume capturing traffic. Packet capture parameters (other than mode) are saved in NVRAM.
In order to minimize performance impact on the WAP device while traffic capture is in progress, you should install capture filters to limit which traffic is sent to the Wireshark tool. When capturing 802.11 traffic, large portion of the captured frames tend to be beacons (typically sent every 100 ms by all APs). Although Wireshark supports a display filter for beacon frames, it does not support a capture filter to prevent the WAP device from forwarding captured beacon packets to the Wireshark tool. In order to reduce the performance impact of capturing the 802.11 beacons, you can disable the capture beacons mode.

